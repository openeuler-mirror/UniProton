#!/usr/bin/env python3
# coding=utf-8
# Transfer kconfig configuration file to buildef/config file.
# Copyright (c) 2009-2023 Huawei Technologies Co., Ltd. All rights reserved.

import os
import sys
import time
import getopt
import re
import logging
import codecs


logging.basicConfig(stream=sys.stdout, level=logging.NOTSET)

HEADER_TYPE_BUILD = 0
HEADER_TYPE_CONFIG = 1
HEADER_TYPE_INVALID = 2

def cmd_help():
    logging.info("Interpret the configuration file which was generated by Kconfig tool, and")
    logging.info("Transfer it to header file which will be used in C code")
    logging.info("Command format:")
    logging.info("   Kconfig2macro.py [-e][-f configFileName] [-o headerFileName]")
    logging.info("The default configFileName is .config")
    logging.info("The default headerFileName is config.h")

def headerType(in_file):
    with open(in_file, 'r') as fd_in:
        lines = fd_in.readlines()
        for line in lines:

            if line.find("CONFIG_OS_HARDWARE_PLATFORM=") >= 0:
                return HEADER_TYPE_BUILD
    return HEADER_TYPE_CONFIG


def write_header(out_file):
    with codecs.open(out_file,
                     'w',
                     encoding='gbk',
                     errors='ignore') as fd_out:
        file_path, file_name = os.path.split(out_file)
        name = ((str(file_name)).split('.'))[0]
        header_macro = '%s_H' % (str.upper(name))
        text = r'''/*
 * Copyright (c) 2009-2022 Huawei Technologies Co., Ltd. All rights reserved.
 *
 * UniProton is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *          http://license.coscl.org.cn/MulanPSL2
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 * Create: 2009-12-22
 * Description: the common part buildef.h
 */
'''

        text = '%s#ifndef %s\n' % (text, header_macro)
        text = '%s#define %s\n' % (text, header_macro)
        text = '%s\n' % (text)
        text = '%s#ifdef __cplusplus\n#if __cplusplus\nextern "C" {\n#endif\n#endif\n' % (text)

        fd_out.write(text)
    return 0


def get_macro_fix(macro):
    prefix = ""
    suffix = "\n"
    if macro == "OS_HARDWARE_PLATFORM" or macro == "OS_CPU_TYPE" or macro == "OS_BYTE_ORDER":
        prefix = '#ifndef %s\n' % (macro)
        suffix = "#endif\n\n"

    return prefix, suffix

def write_macro(fd_out, line, flag):
    export_flag = False
    match_s = re.search(r'\w+', line)
    if match_s is None:
        return

    macro = match_s.group()
    if not macro.startswith("CONFIG_"):
        return

    macro = macro[len("CONFIG_"):]
    if macro.startswith("INTERNAL_"):
        return

    if macro.startswith("EXPORT_"):
        macro = macro[len("EXPORT_"):]
        export_flag = flag

    if line.find("is not set") >= 0:
        value = "NO"
    else:
        expression = line.split("=", 1)
        if len(expression) < 2:
            return
        value = expression[1].strip()
        if value == 'y':
            value = ""
    prefix, suffix = get_macro_fix(macro)
    text = '%s#define %s %s\n%s' %(prefix ,macro, value.strip('"'), suffix)
    if export_flag == True or flag == False:
        fd_out.write(text.rstrip() + "\n\n")
def write_config(in_file, out_file, flag):
    with codecs.open(out_file, 'a+') as fd_out, open(in_file) as fd_in:
        fd_out.write("\n")
        lines = fd_in.readlines()
        for line in lines:
            if line.startswith('##'):
                fd_out(line.replace("##", "/*") + "*/")
            elif line.startswith("CONFIG_"):
                write_macro(fd_out, line, flag)

    return 0

def write_def_config(filename, string):
    with open(filename, 'r', errors='ignore') as fp:
        for line in fp:
            if string in line:
                return line

    with codecs.open(file, 'a+') as fd_in:
        text = '#define %-35s NO \n\n' %(str)

        fd_in.write(text)

    return 0

def write_external_macro(out_file):
    with codecs.open(out_file, 'a+') as fd_out:

        text = '#define OS_LITTLE_ENDIAN 0x1234\n\n#define OS_BIG_ENDIAN 0x4321\n\n#define OS_CORTEX_M4 0x1\n\n#define OS_STM32F407 0x1\n\n'

        fd_out.write(text)

    return 0

def write_c_external_tail(out_file):
    with codecs.open(out_file, 'a+') as fd_out:


        text = '#ifdef __cplusplus\n#if __cplusplus\n}\n#endif\n#endif\n'

        fd_out.write(text)

    return 0

def write_tail(out_file):
    with codecs.open(out_file, 'a+') as fd_out:

        text = '\n#endif\n'

        fd_out.write(text)

    return 0

def wirte_buildef_header(out_file):
    """
    wirte_buildef_header
    :param out_file:
    :return:
    """
    with codecs.open(out_file, 'a+') as fd_out:
        text = "\n/* common macros's definitions */\n"
        text = '%s#include "prt_buildef_common.h"\n' % (text)
        fd_out.write(text)
    return 0

def kconfig2macro(in_file, out_file, flag):
    header_type = headerType(in_file)
    if header_type == HEADER_TYPE_INVALID:
        return -10

    ret = write_header(out_file)
    if ret != 0:
        return ret

    ret = write_config(in_file, out_file, flag)
    if ret != 0:
        return ret

    ret = write_c_external_tail(out_file)
    if ret != 0:
        return ret
    
    if header_type == HEADER_TYPE_BUILD:
        ret_code = wirte_buildef_header(out_file)
        if ret_code != 0:
            return ret_code

    ret = write_tail(out_file)
    if ret != 0:
        return ret

    return 0
def do_cmd(argv, flag):
    in_file = ".config"
    out_file = "config.h"

    try:
        opts, args = getopt.getopt(argv,"ehf:o:",["help", "inFile=", "outFile="])
    except getopt.GetoptError:
        cmd_help()
        return -1

    if len(args) > 0:
        cmd_help()
        return -2

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            cmd_help()
            return 0
        elif opt in ('-e'):
            flag = True
        elif opt in ('-f', '--inFile'):
            in_file = arg
        elif opt in ('-o', '--outFile'):
            out_file = arg
        else:
            logging.error("ERROR: Invalid Input %s", opt)
            cmd_help()
            return -3

    if os.path.exists(in_file) == False:
        logging.info("config input file <%s> doesn't exist", in_file)
        return -4

    return kconfig2macro(in_file, out_file, flag)


if __name__ == "__main__":
    res = do_cmd(sys.argv[1:], False)
    sys.exit(res)
