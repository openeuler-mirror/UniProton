diff -urN ethercat-master/CMakeLists.txt ethercat-master-m/CMakeLists.txt
--- ethercat-master/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ ethercat-master-m/CMakeLists.txt	2023-08-08 19:51:01.667796800 +0800
@@ -0,0 +1 @@
+add_subdirectory(master)
\ No newline at end of file
diff -urN ethercat-master/documentation/Makefile ethercat-master-m/documentation/Makefile
--- ethercat-master/documentation/Makefile	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/documentation/Makefile	1970-01-01 08:00:00.000000000 +0800
@@ -1,94 +0,0 @@
-#------------------------------------------------------------------------------
-#
-#  LaTeX Makefile
-#
-#------------------------------------------------------------------------------
-
-FILE := ethercat_doc
-
-LATEX_OPTIONS := -file-line-error-style
-
-COMMANDS := \
-	alias \
-	config \
-	crc \
-	cstruct \
-	data \
-	debug \
-	domains \
-	download \
-	eoe \
-	foe_read \
-	foe_write \
-	graph \
-	ip \
-	master \
-	pdos \
-	reg_read \
-	reg_write \
-	rescan \
-	sdos \
-	sii_read \
-	sii_write \
-	slaves \
-	soe_read \
-	soe_write \
-	states \
-	upload \
-	version \
-	xml
-
-EXT_PREFIX := external/ethercat_
-EXT_FILES := $(addprefix $(EXT_PREFIX),$(COMMANDS))
-ETHERCAT_CMD := ../tool/ethercat
-ETHERCAT_HELP := $(ETHERCAT_CMD) -h
-
-#------------------------------------------------------------------------------
-
-all: pdf
-
-$(EXT_FILES): $(ETHERCAT_CMD)
-	@mkdir -pv external
-	@echo Creating $@...
-	$(shell $(subst $(EXT_PREFIX),$(ETHERCAT_HELP) ,$@) > $@)
-
-ext: $(EXT_FILES)
-
-pdf: ext
-	$(MAKE) -C images
-	$(MAKE) -C graphs
-
-# compile twice to update the table of contents
-	pdflatex $(LATEX_OPTIONS) $(FILE)
-	pdflatex $(LATEX_OPTIONS) $(FILE)
-
-	pdflatex $(LATEX_OPTIONS) $(FILE)_fr
-	pdflatex $(LATEX_OPTIONS) $(FILE)_fr
-
-index:
-	makeindex $(FILE)
-	makeindex $(FILE).nlo -s nomencl.ist -o $(FILE).nls
-
-	makeindex $(FILE)_fr
-	makeindex $(FILE)_fr.nlo -s nomencl.ist -o $(FILE)_fr.nls
-
-clean:
-	@rm -f \
-		*.aux \
-		*.dvi \
-		*.idx \
-		*.ilg \
-		*.ind \
-		*.lof \
-		*.log \
-		*.lol \
-		*.lot \
-		*.nlo \
-		*.nls \
-		*.out \
-		*.pdf \
-		*.toc \
-		*~ \
-		images/*.bak
-
-#------------------------------------------------------------------------------
diff -urN ethercat-master/documentation/graphs/Makefile ethercat-master-m/documentation/graphs/Makefile
--- ethercat-master/documentation/graphs/Makefile	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/documentation/graphs/Makefile	1970-01-01 08:00:00.000000000 +0800
@@ -1,35 +0,0 @@
-#-----------------------------------------------------------------------------
-#
-# $Id$
-#
-#-----------------------------------------------------------------------------
-
-GRAPHS := \
-	fsm_change \
-	fsm_eoe \
-	fsm_master \
-	fsm_pdo_conf \
-	fsm_pdo_entry_conf \
-	fsm_pdo_entry_read \
-	fsm_pdo_read \
-	fsm_sii \
-	fsm_slave_conf \
-	fsm_slave_scan
-
-#-----------------------------------------------------------------------------
-
-PDF = $(addsuffix .pdf,$(GRAPHS))
-
-#-----------------------------------------------------------------------------
-
-all: pdf
-
-pdf: $(PDF)
-
-%.pdf: %.dot
-	dot -Tpdf -o $@ $<
-
-clean:
-	@rm -f *.pdf
-
-#-----------------------------------------------------------------------------
diff -urN ethercat-master/documentation/images/Makefile ethercat-master-m/documentation/images/Makefile
--- ethercat-master/documentation/images/Makefile	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/documentation/images/Makefile	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-#-----------------------------------------------------------------------------
-#
-# $Id$
-#
-#-----------------------------------------------------------------------------
-
-FIGS := \
-	app-config.fig \
-	attach.fig \
-	dc.fig \
-	fmmus.fig \
-	fsm-coedown.fig \
-	fsm-eoe.fig \
-	interrupt.fig \
-	master-locks.fig \
-	masters.fig \
-	phases.fig \
-	statetrans.fig
-
-FIGPDFS = $(FIGS:.fig=.pdf)
-
-SVGS := \
-	architecture.svg
-
-SVGPDFS = $(SVGS:.svg=.pdf)
-
-all: $(FIGPDFS) $(SVGPDFS)
-
-%.pdf: %.fig
-	fig2dev -L pdf -z A4 -p xxx -c $< $@	
-
-%.pdf: %.svg
-	inkscape --export-pdf=$@ $<
-
-clean:
-	@rm -rv $(FIGPDFS) $(SVGPDFS)
-
-#-----------------------------------------------------------------------------
diff -urN ethercat-master/include/ecrt.h ethercat-master-m/include/ecrt.h
--- ethercat-master/include/ecrt.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/include/ecrt.h	2023-08-08 19:50:38.605139700 +0800
@@ -1920,7 +1920,7 @@
     );
 #else
 ec_request_state_t ecrt_sdo_request_state(
-        ec_sdo_request_t *req /**< SDO request. */
+        const ec_sdo_request_t *req /**< SDO request. */
     );
 #endif
 
@@ -2113,7 +2113,7 @@
     );
 #else
 ec_request_state_t ecrt_reg_request_state(
-        ec_reg_request_t *req /**< Register request. */
+        const ec_reg_request_t *req /**< Register request. */
     );
 #endif
 
diff -urN ethercat-master/master/CMakeLists.txt ethercat-master-m/master/CMakeLists.txt
--- ethercat-master/master/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ ethercat-master-m/master/CMakeLists.txt	2023-08-08 19:51:01.334803300 +0800
@@ -0,0 +1,25 @@
+set(ECRT_SRC
+    coe_emerg_ring.c
+    datagram_pair.c
+    datagram.c
+    domain.c
+    flag.c
+    fmmu_config.c
+    fsm_coe.c
+    fsm_slave.c
+    mailbox.c
+    master.c
+    module.c
+    pdo_entry.c
+    pdo_list.c
+    pdo.c
+    reg_request.c
+    sdo_entry.c
+    sdo_request.c
+    sdo.c
+    slave_config.c
+    slave.c
+    sync_config.c
+    sync.c
+)
+add_library(ethercat_src OBJECT ${ECRT_SRC})
\ No newline at end of file
diff -urN ethercat-master/master/cdev.c ethercat-master-m/master/cdev.c
--- ethercat-master/master/cdev.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/cdev.c	2023-08-08 19:51:00.679585000 +0800
@@ -32,10 +32,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/vmalloc.h>
-#include <linux/mm.h>
-
 #include "cdev.h"
 #include "master.h"
 #include "slave_config.h"
@@ -155,7 +151,7 @@
     ec_cdev_t *cdev = container_of(inode->i_cdev, ec_cdev_t, cdev);
     ec_cdev_priv_t *priv;
 
-    priv = kmalloc(sizeof(ec_cdev_priv_t), GFP_KERNEL);
+    priv = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_cdev_priv_t));
     if (!priv) {
         EC_MASTER_ERR(cdev->master,
                 "Failed to allocate memory for private data structure.\n");
@@ -190,14 +186,14 @@
     }
 
     if (priv->ctx.process_data) {
-        vfree(priv->ctx.process_data);
+        PRT_MemFree(OS_MID_SYS, priv->ctx.process_data);
     }
 
 #if DEBUG
     EC_MASTER_DBG(master, 0, "File closed.\n");
 #endif
 
-    kfree(priv);
+    PRT_MemFree(OS_MID_SYS, priv);
     return 0;
 }
 
diff -urN ethercat-master/master/cdev.h ethercat-master-m/master/cdev.h
--- ethercat-master/master/cdev.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/cdev.h	2023-08-08 19:51:01.312761800 +0800
@@ -37,10 +37,9 @@
 #ifndef __EC_CDEV_H__
 #define __EC_CDEV_H__
 
-#include <linux/fs.h>
-#include <linux/cdev.h>
-
 #include "globals.h"
+#include "sys/stat.h"
+#include "prt_mem.h"
 
 /*****************************************************************************/
 
@@ -48,7 +47,7 @@
 */
 typedef struct {
     ec_master_t *master; /**< Master owning the device. */
-    struct cdev cdev; /**< Character device. */
+    // struct cdev cdev; /**< Character device. */
 } ec_cdev_t;
 
 /*****************************************************************************/
diff -urN ethercat-master/master/coe_emerg_ring.c ethercat-master-m/master/coe_emerg_ring.c
--- ethercat-master/master/coe_emerg_ring.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/coe_emerg_ring.c	2023-08-08 19:51:00.633479900 +0800
@@ -35,8 +35,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "coe_emerg_ring.h"
 
 /*****************************************************************************/
@@ -65,7 +63,7 @@
         )
 {
     if (ring->msgs) {
-        kfree(ring->msgs);
+        PRT_MemFree(OS_MID_SYS, ring->msgs);
     }
 }
 
@@ -89,7 +87,7 @@
     ring->read_index = ring->write_index = 0;
 
     if (ring->msgs) {
-        kfree(ring->msgs);
+        PRT_MemFree(OS_MID_SYS, ring->msgs);
     }
     ring->msgs = NULL;
 
@@ -97,7 +95,7 @@
         return 0;
     }
 
-    ring->msgs = kmalloc(sizeof(ec_coe_emerg_msg_t) * (size + 1), GFP_KERNEL);
+    ring->msgs = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_coe_emerg_msg_t) * (size + 1));
     if (!ring->msgs) {
         return -ENOMEM;
     }
@@ -112,7 +110,7 @@
  */
 void ec_coe_emerg_ring_push(
         ec_coe_emerg_ring_t *ring, /**< Emergency ring. */
-        const u8 *msg /**< Emergency message. */
+        const U8 *msg /**< Emergency message. */
         )
 {
     if (!ring->size ||
@@ -134,7 +132,7 @@
  */
 int ec_coe_emerg_ring_pop(
         ec_coe_emerg_ring_t *ring, /**< Emergency ring. */
-        u8 *msg /**< Memory to store the emergency message. */
+        U8 *msg /**< Memory to store the emergency message. */
         )
 {
     if (ring->read_index == ring->write_index) {
diff -urN ethercat-master/master/coe_emerg_ring.h ethercat-master-m/master/coe_emerg_ring.h
--- ethercat-master/master/coe_emerg_ring.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/coe_emerg_ring.h	2023-08-08 19:51:01.122451800 +0800
@@ -38,13 +38,14 @@
 #define __EC_COE_EMERG_RING_H__
 
 #include "globals.h"
+#include "prt_mem.h"
 
 /*****************************************************************************/
 
 /** EtherCAT CoE emergency message record.
  */
 typedef struct {
-    u8 data[EC_COE_EMERGENCY_MSG_SIZE]; /**< Message data. */
+    U8 data[EC_COE_EMERGENCY_MSG_SIZE]; /**< Message data. */
 } ec_coe_emerg_msg_t;
 
 /*****************************************************************************/
@@ -68,8 +69,8 @@
 void ec_coe_emerg_ring_clear(ec_coe_emerg_ring_t *);
 
 int ec_coe_emerg_ring_size(ec_coe_emerg_ring_t *, size_t);
-void ec_coe_emerg_ring_push(ec_coe_emerg_ring_t *, const u8 *);
-int ec_coe_emerg_ring_pop(ec_coe_emerg_ring_t *, u8 *);
+void ec_coe_emerg_ring_push(ec_coe_emerg_ring_t *, const U8 *);
+int ec_coe_emerg_ring_pop(ec_coe_emerg_ring_t *, U8 *);
 int ec_coe_emerg_ring_clear_ring(ec_coe_emerg_ring_t *);
 int ec_coe_emerg_ring_overruns(ec_coe_emerg_ring_t *);
 
diff -urN ethercat-master/master/datagram.c ethercat-master-m/master/datagram.c
--- ethercat-master/master/datagram.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/datagram.c	2023-08-08 19:51:01.207547900 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "datagram.h"
 #include "master.h"
 
@@ -45,7 +43,7 @@
 
 #define EC_FUNC_HEADER \
     ret = ec_datagram_prealloc(datagram, data_size); \
-    if (unlikely(ret)) \
+    if (ret) \
         return ret; \
     datagram->index = 0; \
     datagram->working_counter = 0; \
@@ -121,7 +119,7 @@
     ec_datagram_unqueue(datagram);
 
     if (datagram->data_origin == EC_ORIG_INTERNAL && datagram->data) {
-        kfree(datagram->data);
+        PRT_MemFree(OS_MID_SYS, datagram->data);
         datagram->data = NULL;
     }
 }
@@ -158,12 +156,12 @@
         return 0;
 
     if (datagram->data) {
-        kfree(datagram->data);
+        PRT_MemFree(OS_MID_SYS, datagram->data);
         datagram->data = NULL;
         datagram->mem_size = 0;
     }
 
-    if (!(datagram->data = kmalloc(size, GFP_KERNEL))) {
+    if (!(datagram->data = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
         EC_ERR("Failed to allocate %zu bytes of datagram memory!\n", size);
         return -ENOMEM;
     }
@@ -280,7 +278,7 @@
 {
     int ret;
 
-    if (unlikely(configured_address == 0x0000))
+    if (configured_address == 0x0000)
         EC_WARN("Using configured station address 0x0000!\n");
 
     EC_FUNC_HEADER;
@@ -305,7 +303,7 @@
 {
     int ret;
 
-    if (unlikely(configured_address == 0x0000))
+    if (configured_address == 0x0000)
         EC_WARN("Using configured station address 0x0000!\n");
 
     EC_FUNC_HEADER;
@@ -330,7 +328,7 @@
 {
     int ret;
 
-    if (unlikely(configured_address == 0x0000))
+    if (configured_address == 0x0000)
         EC_WARN("Using configured station address 0x0000!\n");
 
     EC_FUNC_HEADER;
@@ -355,7 +353,7 @@
 {
     int ret;
 
-    if (unlikely(configured_address == 0x0000))
+    if (configured_address == 0x0000)
         EC_WARN("Using configured station address 0x0000!\n");
 
     EC_FUNC_HEADER;
@@ -567,34 +565,34 @@
         const ec_datagram_t *datagram /**< EtherCAT datagram */
         )
 {
-    printk(KERN_CONT "Datagram ");
+    printf("Datagram ");
     switch (datagram->state) {
         case EC_DATAGRAM_INIT:
-            printk(KERN_CONT "initialized");
+            printf("initialized");
             break;
         case EC_DATAGRAM_QUEUED:
-            printk(KERN_CONT "queued");
+            printf("queued");
             break;
         case EC_DATAGRAM_SENT:
-            printk(KERN_CONT "sent");
+            printf("sent");
             break;
         case EC_DATAGRAM_RECEIVED:
-            printk(KERN_CONT "received");
+            printf("received");
             break;
         case EC_DATAGRAM_TIMED_OUT:
-            printk(KERN_CONT "timed out");
+            printf("timed out");
             break;
         case EC_DATAGRAM_ERROR:
-            printk(KERN_CONT "error");
+            printf("error");
             break;
         case EC_DATAGRAM_INVALID:
-            printk(KERN_CONT "invalid");
+            printf("invalid");
             break;
         default:
-            printk(KERN_CONT "???");
+            printf("???");
     }
 
-    printk(KERN_CONT ".\n");
+    printf(".\n");
 }
 
 /*****************************************************************************/
@@ -608,15 +606,15 @@
         )
 {
     if (datagram->working_counter == 0) {
-        printk(KERN_CONT "No response.");
+        printf("No response.");
     }
     else if (datagram->working_counter > 1) {
-        printk(KERN_CONT "%u slaves responded!", datagram->working_counter);
+        printf("%u slaves responded!", datagram->working_counter);
     }
     else {
-        printk(KERN_CONT "Success.");
+        printf("Success.");
     }
-    printk(KERN_CONT "\n");
+    printf("\n");
 }
 
 /*****************************************************************************/
@@ -627,10 +625,10 @@
         ec_datagram_t *datagram
         )
 {
-    if (jiffies - datagram->stats_output_jiffies > HZ) {
-        datagram->stats_output_jiffies = jiffies;
+    if (get_jiffies() - datagram->stats_output_jiffies > HZ) {
+        datagram->stats_output_jiffies = get_jiffies();
 
-        if (unlikely(datagram->skip_count)) {
+        if (datagram->skip_count) {
             EC_WARN("Datagram %p (%s) was SKIPPED %u time%s.\n",
                     datagram, datagram->name,
                     datagram->skip_count,
@@ -678,7 +676,7 @@
         )
 {
     if (mbox_data->data) {
-        kfree(mbox_data->data);
+        PRT_MemFree(OS_MID_SYS, mbox_data->data);
         mbox_data->data = NULL;
         mbox_data->data_size = 0;
     }
@@ -697,12 +695,12 @@
         )
 {
     if (mbox_data->data) {
-        kfree(mbox_data->data);
+        PRT_MemFree(OS_MID_SYS, mbox_data->data);
         mbox_data->data = NULL;
         mbox_data->data_size = 0;
     }
 
-    if (!(mbox_data->data = kmalloc(size, GFP_KERNEL))) {
+    if (!(mbox_data->data = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
         EC_ERR("Failed to allocate %zu bytes of mailbox data memory!\n", size);
         return -ENOMEM;
     }
diff -urN ethercat-master/master/datagram.h ethercat-master-m/master/datagram.h
--- ethercat-master/master/datagram.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/datagram.h	2023-08-08 19:51:01.580223200 +0800
@@ -37,11 +37,8 @@
 #ifndef __EC_DATAGRAM_H__
 #define __EC_DATAGRAM_H__
 
-#include <linux/list.h>
-#include <linux/time.h>
-#include <linux/timex.h>
-
 #include "globals.h"
+#include "rtos_list.h"
 
 /*****************************************************************************/
 
diff -urN ethercat-master/master/datagram_pair.c ethercat-master-m/master/datagram_pair.c
--- ethercat-master/master/datagram_pair.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/datagram_pair.c	2023-08-08 19:51:00.908103100 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "master.h"
 #include "datagram_pair.h"
 
@@ -81,7 +79,7 @@
     }
 
 #if EC_MAX_NUM_DEVICES > 1
-    if (!(pair->send_buffer = kmalloc(data_size, GFP_KERNEL))) {
+    if (!(pair->send_buffer = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, data_size))) {
         EC_MASTER_ERR(domain->master,
                 "Failed to allocate domain send buffer!\n");
         ret = -ENOMEM;
@@ -162,7 +160,7 @@
 
 #if EC_MAX_NUM_DEVICES > 1
     if (pair->send_buffer) {
-        kfree(pair->send_buffer);
+        PRT_MemFree(OS_MID_SYS, pair->send_buffer);
     }
 #endif
 }
diff -urN ethercat-master/master/datagram_pair.h ethercat-master-m/master/datagram_pair.h
--- ethercat-master/master/datagram_pair.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/datagram_pair.h	2023-08-08 19:51:01.541165200 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_DATAGRAM_PAIR_H__
 #define __EC_DATAGRAM_PAIR_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "datagram.h"
 
diff -urN ethercat-master/master/debug.c ethercat-master-m/master/debug.c
--- ethercat-master/master/debug.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/debug.c	2023-08-08 19:51:00.994190300 +0800
@@ -34,10 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/version.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-
 #include "globals.h"
 #include "master.h"
 #include "debug.h"
diff -urN ethercat-master/master/device.c ethercat-master-m/master/device.c
--- ethercat-master/master/device.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/device.c	2023-08-08 19:51:01.421955000 +0800
@@ -34,11 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/skbuff.h>
-#include <linux/if_ether.h>
-#include <linux/netdevice.h>
-
 #include "device.h"
 #include "master.h"
 
@@ -338,7 +333,7 @@
     // set the right length for the data
     skb->len = ETH_HLEN + size;
 
-    if (unlikely(device->master->debug_level > 1)) {
+    if (device->master->debug_level > 1) {
         EC_MASTER_DBG(device->master, 2, "Sending frame:\n");
         ec_print_data(skb->data, ETH_HLEN + size);
     }
@@ -422,7 +417,7 @@
 
     device->debug_frame_index++;
     device->debug_frame_index %= EC_DEBUG_RING_SIZE;
-    if (unlikely(device->debug_frame_count < EC_DEBUG_RING_SIZE))
+    if (device->debug_frame_count < EC_DEBUG_RING_SIZE)
         device->debug_frame_count++;
 }
 
@@ -482,7 +477,7 @@
 #ifdef EC_HAVE_CYCLES
     device->cycles_poll = get_cycles();
 #endif
-    device->jiffies_poll = jiffies;
+    device->jiffies_poll = get_jiffies();
 #ifdef EC_DEBUG_RING
     do_gettimeofday(&device->timeval_poll);
 #endif
@@ -499,17 +494,17 @@
 {
     unsigned int i;
 
-    s32 tx_frame_rate = (device->tx_count - device->last_tx_count) * 1000;
-    s32 rx_frame_rate = (device->rx_count - device->last_rx_count) * 1000;
-    s32 tx_byte_rate = (device->tx_bytes - device->last_tx_bytes);
-    s32 rx_byte_rate = (device->rx_bytes - device->last_rx_bytes);
+    S32 tx_frame_rate = (device->tx_count - device->last_tx_count) * 1000;
+    S32 rx_frame_rate = (device->rx_count - device->last_rx_count) * 1000;
+    S32 tx_byte_rate = (device->tx_bytes - device->last_tx_bytes);
+    S32 rx_byte_rate = (device->rx_bytes - device->last_rx_bytes);
 
     /* Low-pass filter:
      *      Y_n = y_(n - 1) + T / tau * (x - y_(n - 1))   | T = 1
      *   -> Y_n += (x - y_(n - 1)) / tau
      */
     for (i = 0; i < EC_RATE_COUNT; i++) {
-        s32 n = rate_intervals[i];
+        S32 n = rate_intervals[i];
         device->tx_frame_rates[i] +=
             (tx_frame_rate - device->tx_frame_rates[i]) / n;
         device->rx_frame_rates[i] +=
@@ -559,9 +554,9 @@
 
     EC_MASTER_INFO(master, "Releasing %s device %s.\n", dev_str, mac_str);
 
-    ec_lock_down(&master->device_sem);
+    ec_lock(&master->device_sem);
     ec_device_detach(device);
-    ec_lock_up(&master->device_sem);
+    ec_unlock(&master->device_sem);
 }
 
 /*****************************************************************************/
@@ -642,7 +637,7 @@
     const void *ec_data = data + ETH_HLEN;
     size_t ec_size = size - ETH_HLEN;
 
-    if (unlikely(!data)) {
+    if (!data) {
         EC_MASTER_WARN(device->master, "%s() called with NULL data.\n",
                 __func__);
         return;
@@ -653,7 +648,7 @@
     device->rx_bytes += size;
     device->master->device_stats.rx_bytes += size;
 
-    if (unlikely(device->master->debug_level > 1)) {
+    if (device->master->debug_level > 1) {
         EC_MASTER_DBG(device->master, 2, "Received frame:\n");
         ec_print_data(data, size);
     }
@@ -682,7 +677,7 @@
         uint8_t state /**< new link state */
         )
 {
-    if (unlikely(!device)) {
+    if (!device) {
         EC_WARN("ecdev_set_link() called with null device!\n");
         return;
     }
@@ -707,7 +702,7 @@
         const ec_device_t *device /**< EtherCAT device */
         )
 {
-    if (unlikely(!device)) {
+    if (!device) {
         EC_WARN("ecdev_get_link() called with null device!\n");
         return 0;
     }
@@ -716,16 +711,3 @@
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecdev_withdraw);
-EXPORT_SYMBOL(ecdev_open);
-EXPORT_SYMBOL(ecdev_close);
-EXPORT_SYMBOL(ecdev_receive);
-EXPORT_SYMBOL(ecdev_get_link);
-EXPORT_SYMBOL(ecdev_set_link);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/device.h ethercat-master-m/master/device.h
--- ethercat-master/master/device.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/device.h	2023-08-08 19:51:01.347801600 +0800
@@ -37,10 +37,8 @@
 #ifndef __EC_DEVICE_H__
 #define __EC_DEVICE_H__
 
-#include <linux/interrupt.h>
-
-#include "../devices/ecdev.h"
 #include "globals.h"
+#include "rtos_list.h"
 
 /**
  * Size of the transmit ring.
@@ -72,6 +70,36 @@
 
 /*****************************************************************************/
 
+struct ec_device;
+typedef struct ec_device ec_device_t;
+typedef void (*ec_pollfunc_t)(struct net_device *);
+
+struct net_device_stats {
+    unsigned long rx_packets;
+    unsigned long tx_packets;
+    unsigned long rx_bytes;
+    unsigned long tx_bytes;
+    unsigned long rx_errors;
+    unsigned long tx_errors;
+    unsigned long rx_dropped;
+    unsigned long tx_dropped;
+    unsigned long multicast;
+    unsigned long collisions;
+    unsigned long rx_length_errors;
+    unsigned long rx_over_errors;
+    unsigned long rx_crc_errors;
+    unsigned long rx_frame_errors;
+    unsigned long rx_fifo_errors;
+    unsigned long rx_missed_errors;
+    unsigned long tx_aborted_errors;
+    unsigned long tx_carrier_errors;
+    unsigned long tx_fifo_errors;
+    unsigned long tx_heartbeat_errors;
+    unsigned long tx_window_errors;
+    unsigned long rx_compressed;
+    unsigned long tx_compressed;
+};
+
 /**
    EtherCAT device.
    An EtherCAT device is a network interface card, that is owned by an
@@ -97,26 +125,26 @@
     unsigned long jiffies_poll; /**< jiffies of last poll */
 
     // Frame statistics
-    u64 tx_count; /**< Number of frames sent. */
-    u64 last_tx_count; /**< Number of frames sent of last statistics cycle. */
-    u64 rx_count; /**< Number of frames received. */
-    u64 last_rx_count; /**< Number of frames received of last statistics
+    U64 tx_count; /**< Number of frames sent. */
+    U64 last_tx_count; /**< Number of frames sent of last statistics cycle. */
+    U64 rx_count; /**< Number of frames received. */
+    U64 last_rx_count; /**< Number of frames received of last statistics
                          cycle. */
-    u64 tx_bytes; /**< Number of bytes sent. */
-    u64 last_tx_bytes; /**< Number of bytes sent of last statistics cycle. */
-    u64 rx_bytes; /**< Number of bytes received. */
-    u64 last_rx_bytes; /**< Number of bytes received of last statistics cycle.
+    U64 tx_bytes; /**< Number of bytes sent. */
+    U64 last_tx_bytes; /**< Number of bytes sent of last statistics cycle. */
+    U64 rx_bytes; /**< Number of bytes received. */
+    U64 last_rx_bytes; /**< Number of bytes received of last statistics cycle.
                         */
-    u64 tx_errors; /**< Number of transmit errors. */
-    s32 tx_frame_rates[EC_RATE_COUNT]; /**< Transmit rates in frames/s for
+    U64 tx_errors; /**< Number of transmit errors. */
+    S32 tx_frame_rates[EC_RATE_COUNT]; /**< Transmit rates in frames/s for
                                          different statistics cycle periods.
                                         */
-    s32 rx_frame_rates[EC_RATE_COUNT]; /**< Receive rates in frames/s for
+    S32 rx_frame_rates[EC_RATE_COUNT]; /**< Receive rates in frames/s for
                                          different statistics cycle periods.
                                         */
-    s32 tx_byte_rates[EC_RATE_COUNT]; /**< Transmit rates in byte/s for
+    S32 tx_byte_rates[EC_RATE_COUNT]; /**< Transmit rates in byte/s for
                                         different statistics cycle periods. */
-    s32 rx_byte_rates[EC_RATE_COUNT]; /**< Receive rates in byte/s for
+    S32 rx_byte_rates[EC_RATE_COUNT]; /**< Receive rates in byte/s for
                                         different statistics cycle periods. */
 
 #ifdef EC_DEBUG_IF
@@ -129,6 +157,137 @@
 #endif
 };
 
+struct class {
+    const char *name;
+};
+
+#define IFNAMSIZ 16
+#define MAX_ADDR_LEN 32
+#define TC_MAX_QUEUE 16
+#define TC_BITMASK 15
+
+typedef U64 netdev_features_t;
+
+struct net_device{
+    char                     name[IFNAMSIZ];
+    struct netdev_name_node  *name_node;
+
+    unsigned long            mem_end;
+    unsigned long            mem_start;
+    unsigned long            base_addr;
+
+    unsigned long            state;
+
+    struct list_head         dev_list;
+    struct list_head         napi_list;
+    struct list_head         unreg_list;
+    struct list_head         close_list;
+    struct list_head         ptype_all;
+    struct list_head         ptype_specific;
+
+    struct {
+        struct list_head     upper;
+        struct list_head     lower;
+    } adj_list;
+
+    unsigned int             flags;
+    unsigned long long       priv_flags;
+    const struct net_device_ops *netdev_ops;
+    int                      ifindex;
+    unsigned short           gflags;
+    unsigned short           hard_header_len;
+
+    unsigned int             mtu;
+    unsigned short           needed_headroom;
+    unsigned short           needed_tailroom;
+
+    netdev_features_t        features;
+    netdev_features_t        hw_features;
+    netdev_features_t        wanted_features;
+    netdev_features_t        vlan_features;
+    netdev_features_t        hw_enc_features;
+    netdev_features_t        mpls_features;
+    netdev_features_t        gso_partial_features;
+
+    unsigned int             min_mtu;
+    unsigned int             max_mtu;
+    unsigned short           type;
+    unsigned char            min_header_len;
+    unsigned char            name_assign_type;
+
+    int                      group;
+
+    struct net_device_stats  stats;
+
+    unsigned char            operstate;
+    unsigned char            link_mode;
+    unsigned char            if_port;
+    unsigned char            dma;
+
+    unsigned char            perm_addr[MAX_ADDR_LEN];
+    unsigned char            addr_assign_type;
+    unsigned char            addr_len;
+    unsigned char            upper_level;
+    unsigned char            lower_level;
+
+    unsigned short           neigh_priv_len;
+    unsigned short           dev_id;
+    unsigned short           dev_port;
+    unsigned short           padded;
+
+    int                      irq;
+    unsigned int             promiscuity;
+    unsigned int             allmulti;
+    bool                     uc_promisc;
+
+    const unsigned char      *dev_addr;
+    struct netdev_rx_queue   *_rx;
+    unsigned int             num_rx_queues;
+    unsigned int             real_num_rx_queues;
+    unsigned long            gro_flush_timeout;
+    int                      napi_defer_hard_irqs;
+#define GRO_LEGACY_MAX_SIZE  65536U
+#define GRO_MAX_SIZE         (8 * 65535U)
+
+    unsigned char            broadcast[MAX_ADDR_LEN];
+    unsigned int             num_tx_queues;
+    unsigned int             real_num_tx_queues;
+    unsigned int             tx_queue_len;
+
+    int                      watchdog_timeo;
+    U32                      proto_down_reason;
+    struct list_head         todo_list;
+    struct list_head         link_watch_list;
+
+    enum {
+        RTNL_LINK_INITIALIZED,
+        RTNL_LINK_INITIALIZING,
+    } rtnl_link_state:16;
+
+    bool                     needs_free_netdev;
+    void                     *ml_priv;
+
+#define GSO_MAX_SEGS         65535U
+#define GSO_LEGACY_MAX_SIZE  65536U
+#define GSO_MAX_SIZE         (8 * GSO_MAX_SEGS)
+
+    unsigned int             gso_max_size;
+#define TSO_LEGACY_MAX_SIZE  65536
+#define TSO_MAX_SIZE         UINT_MAX
+    unsigned int             tso_max_size;
+    U16                      gso_max_segs;
+#define TSO_MAX_SEGS         U16_MAX
+    U16                      tso_max_segs;
+    S16                      num_tc;
+    U8                       prio_tc_map[TC_BITMASK + 1];
+
+    bool                     proto_down;
+    unsigned                 wol_enabled:1;
+    unsigned                 threaded:1;
+    struct list_head         net_notifier_list;
+    U8                       dev_addr_shadow[MAX_ADDR_LEN];
+};
+
 /*****************************************************************************/
 
 int ec_device_init(ec_device_t *, ec_master_t *);
diff -urN ethercat-master/master/domain.c ethercat-master-m/master/domain.c
--- ethercat-master/master/domain.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/domain.c	2023-08-08 19:51:01.180533200 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-
 #include "globals.h"
 #include "master.h"
 #include "slave_config.h"
@@ -100,14 +98,14 @@
     ec_datagram_pair_t *datagram_pair, *next_pair;
 
     // lockdep_assert_held(&domain->master->domains_lock);
-    ec_lock_down(&domain->datagram_pairs_lock);
+    ec_lock(&domain->datagram_pairs_lock);
     // dequeue and free datagrams
-    list_for_each_entry_safe(datagram_pair, next_pair,
+    list_for_each_entry_safe(datagram_pair, next_pair, ec_datagram_pair_t,
             &domain->datagram_pairs, list) {
         ec_datagram_pair_clear(datagram_pair);
-        kfree(datagram_pair);
+        PRT_MemFree(OS_MID_SYS, datagram_pair);
     }
-    ec_lock_up(&domain->datagram_pairs_lock);
+    ec_unlock(&domain->datagram_pairs_lock);
 
     ec_domain_clear_data(domain);
 }
@@ -122,7 +120,7 @@
 {
     // lockdep_assert_held(&domain->master->domains_lock);
     if (domain->data_origin == EC_ORIG_INTERNAL && domain->data) {
-        kfree(domain->data);
+        PRT_MemFree(OS_MID_SYS, domain->data);
     }
 
     domain->data = NULL;
@@ -200,7 +198,7 @@
     ec_datagram_pair_t *datagram_pair;
     int ret;
 
-    if (!(datagram_pair = kmalloc(sizeof(ec_datagram_pair_t), GFP_KERNEL))) {
+    if (!(datagram_pair = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_datagram_pair_t)))) {
         EC_MASTER_ERR(domain->master,
                 "Failed to allocate domain datagram pair!\n");
         return -ENOMEM;
@@ -209,7 +207,7 @@
     ret = ec_datagram_pair_init(datagram_pair, domain, logical_offset, data,
             data_size, used);
     if (ret) {
-        kfree(datagram_pair);
+        PRT_MemFree(OS_MID_SYS, datagram_pair);
         return ret;
     }
 
@@ -221,9 +219,9 @@
             datagram_pair->expected_working_counter);
 
 
-    ec_lock_down(&domain->datagram_pairs_lock);
+    ec_lock(&domain->datagram_pairs_lock);
     list_add_tail(&datagram_pair->list, &domain->datagram_pairs);
-    ec_lock_up(&domain->datagram_pairs_lock);
+    ec_unlock(&domain->datagram_pairs_lock);
     return 0;
 }
 
@@ -289,7 +287,7 @@
     memset(datagram_used, 0, sizeof(datagram_used));
     for (curr_fmmu = datagram_first_fmmu;
             &curr_fmmu->list != &datagram_end_fmmu->list;
-            curr_fmmu = list_next_entry(curr_fmmu, list)) {
+            curr_fmmu = list_next_entry(curr_fmmu, ec_fmmu_config_t, list)) {
         if (shall_count(curr_fmmu, datagram_first_fmmu)) {
             datagram_used[curr_fmmu->dir]++;
         }
@@ -331,7 +329,7 @@
 
     if (domain->data_size && domain->data_origin == EC_ORIG_INTERNAL) {
         if (!(domain->data =
-                    (uint8_t *) kmalloc(domain->data_size, GFP_KERNEL))) {
+                    (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, domain->data_size))) {
             EC_MASTER_ERR(domain->master, "Failed to allocate %zu bytes"
                     " internal memory for domain %u!\n",
                     domain->data_size, domain->index);
@@ -348,7 +346,7 @@
             list_entry(domain->fmmu_configs.next, ec_fmmu_config_t, list);
     }
 
-    list_for_each_entry(fmmu, &domain->fmmu_configs, list) {
+    list_for_each_entry(fmmu, ec_fmmu_config_t, &domain->fmmu_configs, list) {
         if (fmmu->data_size > EC_MAX_DATA_SIZE) {
             EC_MASTER_ERR(domain->master,
                 "FMMU size %u bytes exceeds maximum data size %u",
@@ -396,8 +394,8 @@
             domain->logical_base_address, domain->data_size,
             domain->expected_working_counter);
 
-    ec_lock_down(&domain->datagram_pairs_lock);
-    list_for_each_entry(datagram_pair, &domain->datagram_pairs, list) {
+    ec_lock(&domain->datagram_pairs_lock);
+    list_for_each_entry(datagram_pair, ec_datagram_pair_t, &domain->datagram_pairs, list) {
         const ec_datagram_t *datagram =
             &datagram_pair->datagrams[EC_DEVICE_MAIN];
         EC_MASTER_INFO(domain->master, "  Datagram %s: Logical offset 0x%08x,"
@@ -405,7 +403,7 @@
                 EC_READ_U32(datagram->address), datagram->data_size,
                 ec_datagram_type_string(datagram), datagram);
     }
-    ec_lock_up(&domain->datagram_pairs_lock);
+    ec_unlock(&domain->datagram_pairs_lock);
 
     return 0;
 }
@@ -419,7 +417,7 @@
     const ec_fmmu_config_t *fmmu;
     unsigned int num = 0;
 
-    list_for_each_entry(fmmu, &domain->fmmu_configs, list) {
+    list_for_each_entry(fmmu, ec_fmmu_config_t, &domain->fmmu_configs, list) {
         num++;
     }
 
@@ -439,7 +437,7 @@
 {
     const ec_fmmu_config_t *fmmu;
 
-    list_for_each_entry(fmmu, &domain->fmmu_configs, list) {
+    list_for_each_entry(fmmu, ec_fmmu_config_t, &domain->fmmu_configs, list) {
         if (pos--)
             continue;
         return fmmu;
@@ -557,8 +555,8 @@
     EC_MASTER_DBG(domain->master, 1, "domain %u process\n", domain->index);
 #endif
 
-    ec_lock_down(&domain->datagram_pairs_lock);
-    list_for_each_entry(pair, &domain->datagram_pairs, list) {
+    ec_lock(&domain->datagram_pairs_lock);
+    list_for_each_entry(pair, ec_datagram_pair_t, &domain->datagram_pairs, list) {
 #if EC_MAX_NUM_DEVICES > 1
         datagram_pair_wc = ec_datagram_pair_process(pair, wc_sum);
 #else
@@ -645,7 +643,7 @@
         }
 #endif // EC_MAX_NUM_DEVICES > 1
     }
-    ec_lock_up(&domain->datagram_pairs_lock);
+    ec_unlock(&domain->datagram_pairs_lock);
 
 #if EC_MAX_NUM_DEVICES > 1
     redundant_wc = 0;
@@ -694,8 +692,8 @@
     }
 
     if (domain->working_counter_changes &&
-        jiffies - domain->notify_jiffies > HZ) {
-        domain->notify_jiffies = jiffies;
+        get_jiffies() - domain->notify_jiffies > HZ) {
+        domain->notify_jiffies = get_jiffies();
         if (domain->working_counter_changes == 1) {
             EC_MASTER_INFO(domain->master, "Domain %u: Working counter"
                     " changed to %u/%u", domain->index,
@@ -708,19 +706,19 @@
         }
 #if EC_MAX_NUM_DEVICES > 1
         if (ec_master_num_devices(domain->master) > 1) {
-            printk(KERN_CONT " (");
+            printf(" (");
             for (dev_idx = EC_DEVICE_MAIN;
                     dev_idx < ec_master_num_devices(domain->master);
                     dev_idx++) {
-                printk(KERN_CONT "%u", domain->working_counter[dev_idx]);
+                printf("%u", domain->working_counter[dev_idx]);
                 if (dev_idx + 1 < ec_master_num_devices(domain->master)) {
-                    printk(KERN_CONT "+");
+                    printf("+");
                 }
             }
-            printk(KERN_CONT ")");
+            printf(")");
         }
 #endif
-        printk(KERN_CONT ".\n");
+        printf(".\n");
 
         domain->working_counter_changes = 0;
     }
@@ -734,8 +732,8 @@
     ec_datagram_pair_t *datagram_pair;
     ec_device_index_t dev_idx;
 
-    ec_lock_down(&domain->datagram_pairs_lock);
-    list_for_each_entry(datagram_pair, &domain->datagram_pairs, list) {
+    ec_lock(&domain->datagram_pairs_lock);
+    list_for_each_entry(datagram_pair, ec_datagram_pair_t, &domain->datagram_pairs, list) {
 
 #if EC_MAX_NUM_DEVICES > 1
         /* copy main data to send buffer */
@@ -756,7 +754,7 @@
                     &datagram_pair->datagrams[dev_idx]);
         }
     }
-    ec_lock_up(&domain->datagram_pairs_lock);
+    ec_unlock(&domain->datagram_pairs_lock);
 }
 
 /*****************************************************************************/
@@ -787,17 +785,3 @@
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecrt_domain_reg_pdo_entry_list);
-EXPORT_SYMBOL(ecrt_domain_size);
-EXPORT_SYMBOL(ecrt_domain_external_memory);
-EXPORT_SYMBOL(ecrt_domain_data);
-EXPORT_SYMBOL(ecrt_domain_process);
-EXPORT_SYMBOL(ecrt_domain_queue);
-EXPORT_SYMBOL(ecrt_domain_state);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/domain.h ethercat-master-m/master/domain.h
--- ethercat-master/master/domain.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/domain.h	2023-08-08 19:51:01.297754500 +0800
@@ -37,13 +37,14 @@
 #ifndef __EC_DOMAIN_H__
 #define __EC_DOMAIN_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "datagram.h"
 #include "master.h"
 #include "fmmu_config.h"
 #include "locks.h"
+#include "rtos_list.h"
+
+#define EC_MAX_NUM_DEVICES 1
 
 /*****************************************************************************/
 
diff -urN ethercat-master/master/eoe_request.c ethercat-master-m/master/eoe_request.c
--- ethercat-master/master/eoe_request.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/eoe_request.c	2023-08-08 19:51:00.821931700 +0800
@@ -33,10 +33,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/slab.h>
-
 #include "eoe_request.h"
 
 /*****************************************************************************/
diff -urN ethercat-master/master/eoe_request.h ethercat-master-m/master/eoe_request.h
--- ethercat-master/master/eoe_request.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/eoe_request.h	2023-08-08 19:51:01.267675400 +0800
@@ -37,9 +37,6 @@
 #ifndef __EC_EOE_REQUEST_H__
 #define __EC_EOE_REQUEST_H__
 
-#include <linux/list.h>
-#include <linux/etherdevice.h> // ETH_ALEN
-
 #include "globals.h"
 
 /*****************************************************************************/
diff -urN ethercat-master/master/ethernet.c ethercat-master-m/master/ethernet.c
--- ethercat-master/master/ethernet.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/ethernet.c	2023-08-08 19:51:01.521078200 +0800
@@ -34,10 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/version.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-
 #include "globals.h"
 #include "master.h"
 #include "slave.h"
@@ -139,7 +135,7 @@
     ec_eoe_t **priv;
     int ret = 0;
     char name[EC_DATAGRAM_NAME_SIZE];
-    u8 mac_addr[ETH_ALEN];
+    U8 mac_addr[ETH_ALEN];
 
     struct net_device *dev;
     unsigned char lo_mac[ETH_ALEN] = {0};
@@ -317,7 +313,7 @@
 
     if (eoe->tx_frame) {
         dev_kfree_skb(eoe->tx_frame->skb);
-        kfree(eoe->tx_frame);
+        PRT_MemFree(OS_MID_SYS, eoe->tx_frame);
     }
 
     if (eoe->rx_skb)
@@ -336,16 +332,16 @@
 {
     ec_eoe_frame_t *frame, *next;
 
-    ec_lock_down(&eoe->tx_queue_sem);
+    ec_lock(&eoe->tx_queue_sem);
 
     list_for_each_entry_safe(frame, next, &eoe->tx_queue, queue) {
         list_del(&frame->queue);
         dev_kfree_skb(frame->skb);
-        kfree(frame);
+        PRT_MemFree(OS_MID_SYS, frame);
     }
     eoe->tx_queued_frames = 0;
 
-    ec_lock_up(&eoe->tx_queue_sem);
+    ec_unlock(&eoe->tx_queue_sem);
 }
 
 /*****************************************************************************/
@@ -393,14 +389,14 @@
 #if EOE_DEBUG_LEVEL >= 3
     EC_SLAVE_DBG(eoe->slave, 0, "");
     for (i = 0; i < current_size; i++) {
-        printk(KERN_CONT "%02X ",
+        printf("%02X ",
                 eoe->tx_frame->skb->data[eoe->tx_offset + i]);
         if ((i + 1) % 16 == 0) {
-            printk(KERN_CONT "\n");
+            printf("\n");
             EC_SLAVE_DBG(eoe->slave, 0, "");
         }
     }
-    printk(KERN_CONT "\n");
+    printf("\n");
 #endif
 
     data = ec_slave_mbox_prepare_send(eoe->slave, &eoe->datagram,
@@ -442,12 +438,12 @@
     eoe->state(eoe);
 
     // update statistics
-    if (jiffies - eoe->rate_jiffies > HZ) {
+    if (get_jiffies() - eoe->rate_jiffies > HZ) {
         eoe->rx_rate = eoe->rx_counter;
         eoe->tx_rate = eoe->tx_counter;
         eoe->rx_counter = 0;
         eoe->tx_counter = 0;
-        eoe->rate_jiffies = jiffies;
+        eoe->rate_jiffies = get_jiffies();
     }
 
     ec_datagram_output_stats(&eoe->datagram);
@@ -668,13 +664,13 @@
 #if EOE_DEBUG_LEVEL >= 3
     EC_SLAVE_DBG(eoe->slave, 0, "");
     for (i = 0; i < rec_size - 4; i++) {
-        printk(KERN_CONT "%02X ", data[i + 4]);
+        printf("%02X ", data[i + 4]);
         if ((i + 1) % 16 == 0) {
-            printk(KERN_CONT "\n");
+            printf("\n");
             EC_SLAVE_DBG(eoe->slave, 0, "");
         }
     }
-    printk(KERN_CONT "\n");
+    printf("\n");
 #endif
 
     data_size = time_appended ? rec_size - 8 : rec_size - 4;
@@ -784,10 +780,10 @@
         return;
     }
 
-    ec_lock_down(&eoe->tx_queue_sem);
+    ec_lock(&eoe->tx_queue_sem);
 
     if (!eoe->tx_queued_frames || list_empty(&eoe->tx_queue)) {
-        ec_lock_up(&eoe->tx_queue_sem);
+        ec_unlock(&eoe->tx_queue_sem);
         eoe->tx_idle = 1;
         // no data available.
         // start a new receive immediately.
@@ -808,7 +804,7 @@
     }
 
     eoe->tx_queued_frames--;
-    ec_lock_up(&eoe->tx_queue_sem);
+    ec_unlock(&eoe->tx_queue_sem);
 
     eoe->tx_idle = 0;
 
@@ -819,7 +815,7 @@
 
     if (ec_eoe_send(eoe)) {
         dev_kfree_skb(eoe->tx_frame->skb);
-        kfree(eoe->tx_frame);
+        PRT_MemFree(OS_MID_SYS, eoe->tx_frame);
         eoe->tx_frame = NULL;
         eoe->stats.tx_errors++;
         eoe->state = ec_eoe_state_rx_start;
@@ -886,14 +882,14 @@
         eoe->stats.tx_bytes += eoe->tx_frame->skb->len;
         eoe->tx_counter += eoe->tx_frame->skb->len;
         dev_kfree_skb(eoe->tx_frame->skb);
-        kfree(eoe->tx_frame);
+        PRT_MemFree(OS_MID_SYS, eoe->tx_frame);
         eoe->tx_frame = NULL;
         eoe->state = ec_eoe_state_rx_start;
     }
     else { // send next fragment
         if (ec_eoe_send(eoe)) {
             dev_kfree_skb(eoe->tx_frame->skb);
-            kfree(eoe->tx_frame);
+            PRT_MemFree(OS_MID_SYS, eoe->tx_frame);
             eoe->tx_frame = NULL;
             eoe->stats.tx_errors++;
 #if EOE_DEBUG_LEVEL >= 1
@@ -972,7 +968,7 @@
 #endif
 
     if (!(frame =
-          (ec_eoe_frame_t *) kmalloc(sizeof(ec_eoe_frame_t), GFP_ATOMIC))) {
+          (ec_eoe_frame_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_eoe_frame_t)))) {
         if (printk_ratelimit())
             EC_SLAVE_WARN(eoe->slave, "EoE TX: low on mem. frame dropped.\n");
         return 1;
@@ -980,14 +976,14 @@
 
     frame->skb = skb;
 
-    ec_lock_down(&eoe->tx_queue_sem);
+    ec_lock(&eoe->tx_queue_sem);
     list_add_tail(&frame->queue, &eoe->tx_queue);
     eoe->tx_queued_frames++;
     if (eoe->tx_queued_frames == eoe->tx_queue_size) {
         netif_stop_queue(dev);
         eoe->tx_queue_active = 0;
     }
-    ec_lock_up(&eoe->tx_queue_sem);
+    ec_unlock(&eoe->tx_queue_sem);
 
 #if EOE_DEBUG_LEVEL >= 2
     EC_SLAVE_DBG(eoe->slave, 0, "EoE %s TX queued frame"
diff -urN ethercat-master/master/ethernet.h ethercat-master-m/master/ethernet.h
--- ethercat-master/master/ethernet.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/ethernet.h	2023-08-08 19:51:01.108420900 +0800
@@ -37,9 +37,6 @@
 #ifndef __EC_ETHERNET_H__
 #define __EC_ETHERNET_H__
 
-#include <linux/list.h>
-#include <linux/netdevice.h>
-
 #include "globals.h"
 #include "locks.h"
 #include "slave.h"
diff -urN ethercat-master/master/flag.c ethercat-master-m/master/flag.c
--- ethercat-master/master/flag.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/flag.c	2023-08-08 19:51:01.052244800 +0800
@@ -25,8 +25,6 @@
 
 /****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "flag.h"
 
 /*****************************************************************************/
@@ -43,7 +41,7 @@
         return -EINVAL;
     }
 
-    if (!(flag->key = (uint8_t *) kmalloc(strlen(key) + 1, GFP_KERNEL))) {
+    if (!(flag->key = (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, strlen(key) + 1))) {
         return -ENOMEM;
     }
 
@@ -61,7 +59,7 @@
         )
 {
     if (flag->key) {
-        kfree(flag->key);
+        PRT_MemFree(OS_MID_SYS, flag->key);
         flag->key = NULL;
     }
 }
diff -urN ethercat-master/master/flag.h ethercat-master-m/master/flag.h
--- ethercat-master/master/flag.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/flag.h	2023-08-08 19:51:01.282717600 +0800
@@ -29,7 +29,9 @@
 #ifndef __EC_FLAG_H__
 #define __EC_FLAG_H__
 
-#include <linux/list.h>
+#include "securec.h"
+#include "rtos_list.h"
+#include "prt_mem.h"
 
 /****************************************************************************/
 
diff -urN ethercat-master/master/foe_request.c ethercat-master-m/master/foe_request.c
--- ethercat-master/master/foe_request.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/foe_request.c	2023-08-08 19:51:01.080388600 +0800
@@ -32,11 +32,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-
 #include "foe_request.h"
 #include "foe.h"
 
@@ -92,7 +87,7 @@
         )
 {
     if (req->buffer) {
-        vfree(req->buffer);
+        PRT_MemFree(OS_MID_SYS, req->buffer);
         req->buffer = NULL;
     }
 
@@ -120,7 +115,7 @@
 
     ec_foe_request_clear_data(req);
 
-    if (!(req->buffer = (uint8_t *) vmalloc(size))) {
+    if (!(req->buffer = (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
         EC_ERR("Failed to allocate %zu bytes of FoE memory.\n", size);
         return -ENOMEM;
     }
@@ -167,7 +162,7 @@
         )
 {
     return req->issue_timeout
-        && jiffies - req->jiffies_start > HZ * req->issue_timeout / 1000;
+        && get_jiffies() - req->jiffies_start > HZ * req->issue_timeout / 1000;
 }
 
 /*****************************************************************************/
@@ -219,7 +214,7 @@
     req->dir = EC_DIR_INPUT;
     req->state = EC_INT_REQUEST_QUEUED;
     req->result = FOE_BUSY;
-    req->jiffies_start = jiffies;
+    req->jiffies_start = get_jiffies();
 }
 
 /*****************************************************************************/
@@ -233,7 +228,7 @@
     req->dir = EC_DIR_OUTPUT;
     req->state = EC_INT_REQUEST_QUEUED;
     req->result = FOE_BUSY;
-    req->jiffies_start = jiffies;
+    req->jiffies_start = get_jiffies();
 }
 
 /*****************************************************************************/
diff -urN ethercat-master/master/foe_request.h ethercat-master-m/master/foe_request.h
--- ethercat-master/master/foe_request.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/foe_request.h	2023-08-08 19:51:01.237602600 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_FOE_REQUEST_H__
 #define __EC_FOE_REQUEST_H__
 
-#include <linux/list.h>
-
 #include "../include/ecrt.h"
 
 #include "globals.h"
diff -urN ethercat-master/master/fsm_change.c ethercat-master-m/master/fsm_change.c
--- ethercat-master/master/fsm_change.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_change.c	2023-08-08 19:51:00.864026200 +0800
@@ -209,7 +209,7 @@
         return;
     }
 
-    if (unlikely(datagram->working_counter > 1)) {
+    if (datagram->working_counter > 1) {
         char state_str[EC_STATE_STRING_SIZE];
         ec_state_string(fsm->requested_state, state_str, 0);
         fsm->state = ec_fsm_change_state_error;
diff -urN ethercat-master/master/fsm_coe.c ethercat-master-m/master/fsm_coe.c
--- ethercat-master/master/fsm_coe.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_coe.c	2023-08-08 19:51:01.009197900 +0800
@@ -498,7 +498,7 @@
         )
 {
     ec_slave_t *slave = fsm->slave;
-    u8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
+    U8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
 			8);
     if (IS_ERR(data)) {
         return PTR_ERR(data);
@@ -668,7 +668,7 @@
             continue;
         }
 
-        if (!(sdo = (ec_sdo_t *) kmalloc(sizeof(ec_sdo_t), GFP_KERNEL))) {
+        if (!(sdo = (ec_sdo_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_sdo_t)))) {
             EC_SLAVE_ERR(slave, "Failed to allocate memory for SDO!\n");
             fsm->state = ec_fsm_coe_error;
             return;
@@ -840,7 +840,7 @@
         )
 {
     ec_slave_t *slave = fsm->slave;
-    u8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
+    U8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
 			10);
     if (IS_ERR(data)) {
         return PTR_ERR(data);
@@ -1005,7 +1005,7 @@
 
     name_size = rec_size - 12;
     if (name_size) {
-        if (!(sdo->name = kmalloc(name_size + 1, GFP_KERNEL))) {
+        if (!(sdo->name = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, name_size + 1))) {
             EC_SLAVE_ERR(slave, "Failed to allocate SDO name!\n");
             fsm->state = ec_fsm_coe_error;
             return;
@@ -1211,7 +1211,7 @@
     uint8_t *data, mbox_prot;
     size_t rec_size, data_size;
     ec_sdo_entry_t *entry;
-    u16 word;
+    U16 word;
 
     // process the data available or initiate a new mailbox read check
     if (slave->mbox_coe_data.payload_size > 0) {
@@ -1302,7 +1302,7 @@
         data_size = rec_size - 16;
 
         if (!(entry = (ec_sdo_entry_t *)
-              kmalloc(sizeof(ec_sdo_entry_t), GFP_KERNEL))) {
+              PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_sdo_entry_t)))) {
             EC_SLAVE_ERR(slave, "Failed to allocate entry!\n");
             fsm->state = ec_fsm_coe_error;
             return;
@@ -1325,7 +1325,7 @@
 
         if (data_size) {
             uint8_t *desc;
-            if (!(desc = kmalloc(data_size + 1, GFP_KERNEL))) {
+            if (!(desc = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, data_size + 1))) {
                 EC_SLAVE_ERR(slave, "Failed to allocate SDO entry name!\n");
                 fsm->state = ec_fsm_coe_error;
                 return;
@@ -1379,7 +1379,7 @@
         ec_datagram_t *datagram /**< Datagram to use. */
         )
 {
-    u8 *data;
+    U8 *data;
     ec_slave_t *slave = fsm->slave;
     ec_sdo_request_t *request = fsm->request;
     uint8_t data_set_size;
@@ -1389,7 +1389,7 @@
         data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
                 EC_COE_DOWN_REQ_HEADER_SIZE);
         if (IS_ERR(data)) {
-            request->errno = PTR_ERR(data);
+            request->err_no = PTR_ERR(data);
             return PTR_ERR(data);
         }
 
@@ -1430,7 +1430,7 @@
         data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
                 data_size);
         if (IS_ERR(data)) {
-            request->errno = PTR_ERR(data);
+            request->err_no = PTR_ERR(data);
             return PTR_ERR(data);
         }
 
@@ -1491,7 +1491,7 @@
 
     if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
-        request->errno = EPROTONOSUPPORT;
+        request->err_no = EPROTONOSUPPORT;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -1499,13 +1499,13 @@
     if (slave->configured_rx_mailbox_size <
             EC_MBOX_HEADER_SIZE + EC_COE_DOWN_REQ_HEADER_SIZE) {
         EC_SLAVE_ERR(slave, "Mailbox too small!\n");
-        request->errno = EOVERFLOW;
+        request->err_no = EOVERFLOW;
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
 
-    fsm->request->jiffies_sent = jiffies;
+    fsm->request->jiffies_sent = get_jiffies();
     fsm->retries = EC_FSM_RETRIES;
 
     if (ec_fsm_coe_prepare_down_start(fsm, datagram)) {
@@ -1536,7 +1536,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE download"
                 " request datagram: ");
@@ -1544,7 +1544,7 @@
         return;
     }
 
-    diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+    diff_ms = (get_jiffies() - fsm->request->jiffies_sent) * 1000 / HZ;
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -1561,7 +1561,7 @@
                 return;
             }
         }
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE download request"
                 " for SDO 0x%04x:%x failed with timeout after %lu ms: ",
@@ -1608,7 +1608,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check"
@@ -1618,7 +1618,7 @@
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox check"
@@ -1642,7 +1642,7 @@
         1000 / HZ;
 
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Timeout after %lu ms while waiting"
@@ -1700,7 +1700,7 @@
     data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
             data_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err_no = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -1746,7 +1746,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE download"
                 " response datagram: ");
@@ -1757,7 +1757,7 @@
     if (fsm->datagram->working_counter != 1) {
         // only an error if data has not already been read by another read request
         if (slave->mbox_coe_data.payload_size == 0) {
-            request->errno = EIO;
+            request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Reception of CoE download response failed: ");
@@ -1805,13 +1805,13 @@
     data = ec_slave_mbox_fetch(slave, &slave->mbox_coe_data, &mbox_prot, &rec_size);
 
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err_no = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
     if (mbox_prot != EC_MBOX_TYPE_COE) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received mailbox protocol 0x%02X as response.\n",
                 mbox_prot);
@@ -1832,7 +1832,7 @@
     }
 
     if (rec_size < 6) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received data are too small (%zu bytes):\n",
                 rec_size);
@@ -1843,7 +1843,7 @@
     if (EC_READ_U16(data) >> 12 == 0x2 && // SDO request
         EC_READ_U8 (data + 2) >> 5 == 0x4) { // abort SDO transfer request
         char subidxstr[10];
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         if (request->complete_access) {
             subidxstr[0] = 0x00;
@@ -1903,7 +1903,7 @@
         return;
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check datagram: ");
@@ -1912,7 +1912,7 @@
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox segment check"
@@ -1936,7 +1936,7 @@
         1000 / HZ;
 
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Timeout while waiting for SDO download"
@@ -1976,7 +1976,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE download response"
@@ -1988,7 +1988,7 @@
     if (fsm->datagram->working_counter != 1) {
         // only an error if data has not already been read by another read request
         if (slave->mbox_coe_data.payload_size == 0) {
-            request->errno = EIO;
+            request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Reception of CoE download response failed: ");
@@ -2035,13 +2035,13 @@
 
     data = ec_slave_mbox_fetch(slave, &slave->mbox_coe_data, &mbox_prot, &rec_size);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err_no = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
     if (mbox_prot != EC_MBOX_TYPE_COE) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received mailbox protocol 0x%02X as response.\n",
                 mbox_prot);
@@ -2062,7 +2062,7 @@
     }
 
     if (rec_size < 6) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received data are too small (%zu bytes):\n",
                 rec_size);
@@ -2073,7 +2073,7 @@
     if (EC_READ_U16(data) >> 12 == 0x2 && // SDO request
         EC_READ_U8 (data + 2) >> 5 == 0x4) { // abort SDO transfer request
         char subidxstr[10];
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         if (request->complete_access) {
             subidxstr[0] = 0x00;
@@ -2110,7 +2110,7 @@
         EC_SLAVE_ERR(slave, "Invalid toggle received during"
                 " segmented download:\n");
         ec_print_data(data, rec_size);
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2141,10 +2141,10 @@
     ec_sdo_request_t *request = fsm->request;
     ec_master_t *master = slave->master;
 
-    u8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
+    U8 *data = ec_slave_mbox_prepare_send(slave, datagram, EC_MBOX_TYPE_COE,
 			10);
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err_no = PTR_ERR(data);
         return PTR_ERR(data);
     }
 
@@ -2182,13 +2182,13 @@
 
     if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)) {
         EC_SLAVE_ERR(slave, "Slave does not support CoE!\n");
-        request->errno = EPROTONOSUPPORT;
+        request->err_no = EPROTONOSUPPORT;
         fsm->state = ec_fsm_coe_error;
         return;
     }
 
     fsm->retries = EC_FSM_RETRIES;
-    fsm->request->jiffies_sent = jiffies;
+    fsm->request->jiffies_sent = get_jiffies();
 
     if (ec_fsm_coe_prepare_up(fsm, datagram)) {
         fsm->state = ec_fsm_coe_error;
@@ -2217,14 +2217,14 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload request: ");
         ec_datagram_print_state(fsm->datagram);
         return;
     }
 
-    diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+    diff_ms = (get_jiffies() - fsm->request->jiffies_sent) * 1000 / HZ;
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -2241,7 +2241,7 @@
                 return;
             }
         }
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE upload request for"
                 " SDO 0x%04x:%x failed with timeout after %lu ms: ",
@@ -2289,7 +2289,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check datagram: ");
@@ -2298,7 +2298,7 @@
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox check"
@@ -2322,7 +2322,7 @@
         1000 / HZ;
 
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Timeout after %lu ms while waiting for"
@@ -2355,7 +2355,7 @@
         ec_slave_mbox_prepare_send(fsm->slave, datagram, EC_MBOX_TYPE_COE,
 				10);
     if (IS_ERR(data)) {
-        fsm->request->errno = PTR_ERR(data);
+        fsm->request->err_no = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2392,7 +2392,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload response"
@@ -2404,7 +2404,7 @@
     if (fsm->datagram->working_counter != 1) {
         // only an error if data has not already been read by another read request
         if (slave->mbox_coe_data.payload_size == 0) {
-            request->errno = EIO;
+            request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Reception of CoE upload response failed: ");
@@ -2457,7 +2457,7 @@
     data = ec_slave_mbox_fetch(slave, &slave->mbox_coe_data, &mbox_prot, &rec_size);
 
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err_no = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2468,7 +2468,7 @@
     }
 
     if (mbox_prot != EC_MBOX_TYPE_COE) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_WARN(slave, "Received mailbox protocol 0x%02X"
                 " as response.\n", mbox_prot);
@@ -2484,7 +2484,7 @@
     }
 
     if (rec_size < 6) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Received currupted SDO upload response"
                 " (%zu bytes)!\n", rec_size);
@@ -2502,7 +2502,7 @@
         } else {
             EC_SLAVE_ERR(slave, "No abort message.\n");
         }
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2513,7 +2513,7 @@
                 " uploading SDO 0x%04X:%02X.\n",
                 request->index, request->subindex);
         ec_print_data(data, rec_size);
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2546,7 +2546,7 @@
         }
 
         if (rec_size < 6 + fsm->complete_size) {
-            request->errno = EIO;
+            request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Received corrupted SDO expedited upload"
                     " response (only %zu bytes)!\n", rec_size);
@@ -2556,13 +2556,13 @@
 
         ret = ec_sdo_request_copy_data(request, data + 6, fsm->complete_size);
         if (ret) {
-            request->errno = -ret;
+            request->err_no = -ret;
             fsm->state = ec_fsm_coe_error;
             return;
         }
     } else { // normal
         if (rec_size < 10) {
-            request->errno = EIO;
+            request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             EC_SLAVE_ERR(slave, "Received currupted SDO normal upload"
                     " response (only %zu bytes)!\n", rec_size);
@@ -2575,14 +2575,14 @@
 
         ret = ec_sdo_request_alloc(request, fsm->complete_size);
         if (ret) {
-            request->errno = -ret;
+            request->err_no = -ret;
             fsm->state = ec_fsm_coe_error;
             return;
         }
 
         ret = ec_sdo_request_copy_data(request, data + 10, data_size);
         if (ret) {
-            request->errno = -ret;
+            request->err_no = -ret;
             fsm->state = ec_fsm_coe_error;
             return;
         }
@@ -2627,7 +2627,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload segment"
                 " request datagram: ");
@@ -2636,7 +2636,7 @@
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         EC_SLAVE_ERR(slave, "Reception of CoE upload segment"
                 " request failed: ");
@@ -2676,7 +2676,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE mailbox check"
@@ -2686,7 +2686,7 @@
     }
 
     if (fsm->datagram->working_counter != 1) {
-        fsm->request->errno = EIO;
+        fsm->request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Reception of CoE mailbox check datagram"
@@ -2710,7 +2710,7 @@
         1000 / HZ;
 
         if (diff_ms >= fsm->request->response_timeout) {
-            fsm->request->errno = EIO;
+            fsm->request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Timeout while waiting for SDO upload"
@@ -2750,7 +2750,7 @@
     }
 
     if (fsm->datagram->state != EC_DATAGRAM_RECEIVED) {
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         ec_read_mbox_lock_clear(slave);
         EC_SLAVE_ERR(slave, "Failed to receive CoE upload segment"
@@ -2762,7 +2762,7 @@
     if (fsm->datagram->working_counter != 1) {
         // only an error if data has not already been read by another read request
         if (slave->mbox_coe_data.payload_size == 0) {
-            request->errno = EIO;
+            request->err_no = EIO;
             fsm->state = ec_fsm_coe_error;
             ec_read_mbox_lock_clear(slave);
             EC_SLAVE_ERR(slave, "Reception of CoE upload segment"
@@ -2814,7 +2814,7 @@
     data = ec_slave_mbox_fetch(slave, &slave->mbox_coe_data, &mbox_prot, &rec_size);
 
     if (IS_ERR(data)) {
-        request->errno = PTR_ERR(data);
+        request->err_no = PTR_ERR(data);
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2827,7 +2827,7 @@
     if (mbox_prot != EC_MBOX_TYPE_COE) {
         EC_SLAVE_ERR(slave, "Received mailbox protocol 0x%02X as response.\n",
                 mbox_prot);
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2844,7 +2844,7 @@
         EC_SLAVE_ERR(slave, "Received currupted SDO upload"
                 " segment response!\n");
         ec_print_data(data, rec_size);
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2855,7 +2855,7 @@
                request->index, request->subindex);
         request->abort_code = EC_READ_U32(data + 6);
         ec_canopen_abort_msg(slave, request->abort_code);
-        request->errno = EIO;
+        request->err_no = EIO;
         fsm->state = ec_fsm_coe_error;
         return;
     }
@@ -2884,7 +2884,7 @@
         EC_SLAVE_ERR(slave, "SDO upload 0x%04X:%02X failed: Fragment"
                 " exceeding complete size!\n",
                 request->index, request->subindex);
-        request->errno = EOVERFLOW;
+        request->err_no = EOVERFLOW;
         fsm->state = ec_fsm_coe_error;
         return;
     }
diff -urN ethercat-master/master/fsm_eoe.c ethercat-master-m/master/fsm_eoe.c
--- ethercat-master/master/fsm_eoe.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_eoe.c	2023-08-08 19:51:00.777868300 +0800
@@ -239,7 +239,7 @@
         ec_print_data(data, cur - data);
     }
 
-    fsm->request->jiffies_sent = jiffies;
+    fsm->request->jiffies_sent = get_jiffies();
 
     return 0;
 }
@@ -300,7 +300,7 @@
 
     if (fsm->datagram->working_counter != 1) {
         unsigned long diff_ms =
-            (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+            (get_jiffies() - fsm->request->jiffies_sent) * 1000 / HZ;
 
         if (!fsm->datagram->working_counter) {
             if (diff_ms < EC_EOE_RESPONSE_TIMEOUT) {
diff -urN ethercat-master/master/fsm_foe.c ethercat-master-m/master/fsm_foe.c
--- ethercat-master/master/fsm_foe.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_foe.c	2023-08-08 19:51:01.502045400 +0800
@@ -615,7 +615,7 @@
         return;
     }
 
-    fsm->jiffies_start = jiffies;
+    fsm->jiffies_start = get_jiffies();
 
     // mailbox read check is skipped if a read request is already ongoing
     if (ec_read_mbox_locked(slave)) {
@@ -997,12 +997,12 @@
         // no more data fits into the delivered buffer
         // ... wait for new read request
         EC_SLAVE_ERR(slave, "Data do not fit in receive buffer!\n");
-        printk(KERN_CONT "  rx_buffer_size = %d\n", fsm->rx_buffer_size);
-        printk(KERN_CONT "rx_buffer_offset = %d\n", fsm->rx_buffer_offset);
-        printk(KERN_CONT "        rec_size = %zd\n", rec_size);
-        printk(KERN_CONT " rx_mailbox_size = %d\n",
+        printf("  rx_buffer_size = %d\n", fsm->rx_buffer_size);
+        printf("rx_buffer_offset = %d\n", fsm->rx_buffer_offset);
+        printf("        rec_size = %zd\n", rec_size);
+        printf(" rx_mailbox_size = %d\n",
                 slave->configured_rx_mailbox_size);
-        printk(KERN_CONT "  rx_last_packet = %d\n", fsm->rx_last_packet);
+        printf("  rx_last_packet = %d\n", fsm->rx_last_packet);
         fsm->request->result = FOE_READY;
     }
 }
diff -urN ethercat-master/master/fsm_master.c ethercat-master-m/master/fsm_master.c
--- ethercat-master/master/fsm_master.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_master.c	2023-08-08 19:51:00.949139900 +0800
@@ -334,20 +334,20 @@
     }
 
     if (fsm->rescan_required) {
-        ec_lock_down(&master->scan_sem);
+        ec_lock(&master->scan_sem);
         if (!master->allow_scan) {
-            ec_lock_up(&master->scan_sem);
+            ec_unlock(&master->scan_sem);
         } else {
             unsigned int count = 0, next_dev_slave, ring_position;
             ec_device_index_t dev_idx;
 
             master->scan_busy = 1;
-            ec_lock_up(&master->scan_sem);
+            ec_unlock(&master->scan_sem);
 
             // clear all slaves and scan the bus
             fsm->rescan_required = 0;
             fsm->idle = 0;
-            fsm->scan_jiffies = jiffies;
+            fsm->scan_jiffies = get_jiffies();
 
 #ifdef EC_EOE
             ec_master_eoe_stop(master);
@@ -370,7 +370,7 @@
 
             size = sizeof(ec_slave_t) * count;
             if (!(master->slaves =
-                        (ec_slave_t *) kmalloc(size, GFP_KERNEL))) {
+                        (ec_slave_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
                 EC_MASTER_ERR(master, "Failed to allocate %u bytes"
                         " of slave memory!\n", size);
                 master->scan_busy = 0;
@@ -590,7 +590,7 @@
                 || slave->sdo_dictionary_fetched
                 || slave->current_state == EC_SLAVE_STATE_INIT
                 || slave->current_state == EC_SLAVE_STATE_UNKNOWN
-                || jiffies - slave->jiffies_preop < EC_WAIT_SDO_DICT * HZ
+                || get_jiffies() - slave->jiffies_preop < EC_WAIT_SDO_DICT * HZ
                 ) {
             if (!(slave->sii.mailbox_protocols & EC_MBOX_COE)
                     || (slave->sii.has_general
@@ -728,7 +728,7 @@
             case EC_SLAVE_PORT_DOWN:
                 if (port->link.loop_closed) {
                     if (port->link.link_up) {
-                        port->link_detection_jiffies = jiffies;
+                        port->link_detection_jiffies = get_jiffies();
                         port->state = EC_SLAVE_PORT_WAIT;
                     }
                 }
@@ -738,7 +738,7 @@
                 break;
             case EC_SLAVE_PORT_WAIT:
                 if (port->link.link_up) {
-                    if (jiffies - port->link_detection_jiffies >
+                    if (get_jiffies() - port->link_detection_jiffies >
                             HZ * EC_PORT_WAIT_MS / 1000) {
                         port->state = EC_SLAVE_PORT_UP;
                         ec_fsm_master_action_open_port(fsm);
@@ -828,9 +828,9 @@
                 || slave->force_config) && !slave->error_flag) {
 
         // Start slave configuration
-        ec_lock_down(&master->config_sem);
+        ec_lock(&master->config_sem);
         master->config_busy = 1;
-        ec_lock_up(&master->config_sem);
+        ec_unlock(&master->config_sem);
 
         if (master->debug_level) {
             char old_state[EC_STATE_STRING_SIZE],
@@ -1140,11 +1140,11 @@
     if (slave->sii.mailbox_protocols & EC_MBOX_EOE) {
         // create EoE handler for this slave
         ec_eoe_t *eoe;
-        if (!(eoe = kmalloc(sizeof(ec_eoe_t), GFP_KERNEL))) {
+        if (!(eoe = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_eoe_t)))) {
             EC_SLAVE_ERR(slave, "Failed to allocate EoE handler memory!\n");
         } else if (ec_eoe_init(eoe, slave)) {
             EC_SLAVE_ERR(slave, "Failed to init EoE handler!\n");
-            kfree(eoe);
+            PRT_MemFree(OS_MID_SYS, eoe);
         } else {
             list_add_tail(&eoe->list, &master->eoe_handlers);
         }
@@ -1164,7 +1164,7 @@
     }
 
     EC_MASTER_INFO(master, "Bus scanning completed in %lu ms.\n",
-            (jiffies - fsm->scan_jiffies) * 1000 / HZ);
+            (get_jiffies() - fsm->scan_jiffies) * 1000 / HZ);
 
     master->scan_busy = 0;
     wake_up_interruptible(&master->scan_queue);
@@ -1280,21 +1280,21 @@
  *
  * \return New offset.
  */
-u64 ec_fsm_master_dc_offset32(
+U64 ec_fsm_master_dc_offset32(
         ec_fsm_master_t *fsm, /**< Master state machine. */
-        u64 system_time, /**< System time register. */
-        u64 old_offset, /**< Time offset register. */
-        u64 app_time_sent /**< Master app time by reading. */
+        U64 system_time, /**< System time register. */
+        U64 old_offset, /**< Time offset register. */
+        U64 app_time_sent /**< Master app time by reading. */
         )
 {
     ec_slave_t *slave = fsm->slave;
-    u32 system_time32, old_offset32, new_offset;
-    s32 time_diff;
+    U32 system_time32, old_offset32, new_offset;
+    S32 time_diff;
 
-    system_time32 = (u32) system_time;
-    old_offset32 = (u32) old_offset;
+    system_time32 = (U32) system_time;
+    old_offset32 = (U32) old_offset;
 
-    time_diff = (u32) app_time_sent - system_time32;
+    time_diff = (U32) app_time_sent - system_time32;
 
     EC_SLAVE_DBG(slave, 1, "DC 32 bit system time offset calculation:"
             " system_time=%u, app_time=%llu, diff=%i\n",
@@ -1304,7 +1304,7 @@
         new_offset = time_diff + old_offset32;
         EC_SLAVE_DBG(slave, 1, "Setting time offset to %u (was %u)\n",
                 new_offset, old_offset32);
-        return (u64) new_offset;
+        return (U64) new_offset;
     } else {
         EC_SLAVE_DBG(slave, 1, "Not touching time offset.\n");
         return old_offset;
@@ -1317,16 +1317,16 @@
  *
  * \return New offset.
  */
-u64 ec_fsm_master_dc_offset64(
+U64 ec_fsm_master_dc_offset64(
         ec_fsm_master_t *fsm, /**< Master state machine. */
-        u64 system_time, /**< System time register. */
-        u64 old_offset, /**< Time offset register. */
-        u64 app_time_sent /**< Master app time by reading. */
+        U64 system_time, /**< System time register. */
+        U64 old_offset, /**< Time offset register. */
+        U64 app_time_sent /**< Master app time by reading. */
         )
 {
     ec_slave_t *slave = fsm->slave;
-    u64 new_offset;
-    s64 time_diff;
+    U64 new_offset;
+    S64 time_diff;
 
     time_diff = app_time_sent - system_time;
 
@@ -1357,8 +1357,8 @@
     ec_datagram_t *datagram = fsm->datagram;
     ec_slave_t *slave = fsm->slave;
     ec_master_t *master = fsm->master;
-    u64 system_time, old_offset, new_offset;
-    u32 old_delay;
+    U64 system_time, old_offset, new_offset;
+    U32 old_delay;
 
     if (datagram->state == EC_DATAGRAM_TIMED_OUT && fsm->retries--)
         return;
@@ -1379,7 +1379,7 @@
         return;
     }
 
-    if (unlikely(!master->dc_ref_time)) {
+    if (!master->dc_ref_time) {
         EC_MASTER_WARN(master, "No app_time received up to now,"
                     " abort DC time offset calculation.\n");
         // scanning and setting system times complete
diff -urN ethercat-master/master/fsm_pdo.c ethercat-master-m/master/fsm_pdo.c
--- ethercat-master/master/fsm_pdo.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_pdo.c	2023-08-08 19:51:01.039245000 +0800
@@ -105,11 +105,11 @@
         ec_fsm_pdo_t *fsm /**< PDO configuration state machine. */
         )
 {
-    printk(KERN_CONT "Currently assigned PDOs: ");
+    printf("Currently assigned PDOs: ");
     ec_pdo_list_print(&fsm->sync->pdos);
-    printk(KERN_CONT ". PDOs to assign: ");
+    printf(". PDOs to assign: ");
     ec_pdo_list_print(&fsm->pdos);
-    printk(KERN_CONT "\n");
+    printf("\n");
 }
 
 /*****************************************************************************/
@@ -330,7 +330,7 @@
     }
 
     if (!(fsm->pdo = (ec_pdo_t *)
-                kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+                PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_t)))) {
         EC_SLAVE_ERR(fsm->slave, "Failed to allocate PDO.\n");
         ec_fsm_pdo_read_action_next_sync(fsm, datagram);
         return;
@@ -544,11 +544,11 @@
         EC_SLAVE_WARN(fsm->slave, "Slave does not support"
                 " changing the PDO mapping!\n");
         EC_SLAVE_WARN(fsm->slave, "");
-        printk(KERN_CONT "Currently mapped PDO entries: ");
+        printf("Currently mapped PDO entries: ");
         ec_pdo_print_entries(&fsm->slave_pdo);
-        printk(KERN_CONT ". Entries to map: ");
+        printf(". Entries to map: ");
         ec_pdo_print_entries(fsm->pdo);
-        printk(KERN_CONT "\n");
+        printf("\n");
     }
 
     ec_fsm_pdo_conf_action_next_pdo_mapping(fsm, datagram);
diff -urN ethercat-master/master/fsm_pdo_entry.c ethercat-master-m/master/fsm_pdo_entry.c
--- ethercat-master/master/fsm_pdo_entry.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_pdo_entry.c	2023-08-08 19:51:00.723697300 +0800
@@ -93,11 +93,11 @@
         ec_fsm_pdo_entry_t *fsm /**< PDO mapping state machine. */
         )
 {
-    printk(KERN_CONT "Currently mapped PDO entries: ");
+    printf("Currently mapped PDO entries: ");
     ec_pdo_print_entries(fsm->cur_pdo);
-    printk(KERN_CONT ". Entries to map: ");
+    printf(". Entries to map: ");
     ec_pdo_print_entries(fsm->source_pdo);
-    printk(KERN_CONT "\n");
+    printf("\n");
 }
 
 /*****************************************************************************/
@@ -297,7 +297,7 @@
         pdo_entry_info = EC_READ_U32(fsm->request.data);
 
         if (!(pdo_entry = (ec_pdo_entry_t *)
-                    kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+                    PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_entry_t)))) {
             EC_SLAVE_ERR(fsm->slave, "Failed to allocate PDO entry.\n");
             fsm->state = ec_fsm_pdo_entry_state_error;
             return;
@@ -311,7 +311,7 @@
         if (!pdo_entry->index && !pdo_entry->subindex) {
             if (ec_pdo_entry_set_name(pdo_entry, "Gap")) {
                 ec_pdo_entry_clear(pdo_entry);
-                kfree(pdo_entry);
+                PRT_MemFree(OS_MID_SYS, pdo_entry);
                 fsm->state = ec_fsm_pdo_entry_state_error;
                 return;
             }
diff -urN ethercat-master/master/fsm_slave.c ethercat-master-m/master/fsm_slave.c
--- ethercat-master/master/fsm_slave.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_slave.c	2023-08-08 19:51:00.739730000 +0800
@@ -215,7 +215,7 @@
     ec_sdo_request_t *req;
 
     if (slave->config) {
-        list_for_each_entry(req, &slave->config->sdo_requests, list) {
+        list_for_each_entry(req, ec_sdo_request_t, &slave->config->sdo_requests, list) {
             if (req->state == EC_INT_REQUEST_QUEUED || req->state == EC_INT_REQUEST_BUSY) {
                 EC_SLAVE_DBG(slave, 2, "Busy - processing internal SDO request %04X:%02X!\n", req->index, req->subindex);
                 return;
@@ -355,7 +355,7 @@
 
     if (slave->config) {
         // search the first internal register request to be processed
-        list_for_each_entry(reg, &slave->config->reg_requests, list) {
+        list_for_each_entry(reg, ec_reg_request_t, &slave->config->reg_requests, list) {
             if (reg->state == EC_INT_REQUEST_QUEUED) {
                 fsm->reg_request = reg;
                 break;
diff -urN ethercat-master/master/fsm_slave_config.c ethercat-master-m/master/fsm_slave_config.c
--- ethercat-master/master/fsm_slave_config.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_slave_config.c	2023-08-08 19:51:01.442012100 +0800
@@ -1377,7 +1377,7 @@
 
     EC_SLAVE_DBG(slave, 1, "Checking for synchrony.\n");
 
-    fsm->jiffies_start = jiffies;
+    fsm->jiffies_start = get_jiffies();
     ec_datagram_fprd(datagram, slave->station_address, 0x092c, 4);
     ec_datagram_zero(datagram);
     fsm->retries = EC_FSM_RETRIES;
@@ -1401,7 +1401,7 @@
     unsigned long diff_ms;
     ec_sync_signal_t *sync0 = &config->dc_sync[0];
     ec_sync_signal_t *sync1 = &config->dc_sync[1];
-    u64 start_time;
+    U64 start_time;
 
     if (!config) { // config removed in the meantime
         ec_fsm_slave_config_reconfigure(fsm);
@@ -1460,8 +1460,8 @@
     if (sync0->cycle_time) {
         // find correct phase
         if (master->dc_ref_time) {
-            u64 diff, start;
-            u32 remainder, cycle;
+            U64 diff, start;
+            U32 remainder, cycle;
 
             diff = start_time - master->dc_ref_time;
             cycle = sync0->cycle_time + sync1->cycle_time;
diff -urN ethercat-master/master/fsm_slave_scan.c ethercat-master-m/master/fsm_slave_scan.c
--- ethercat-master/master/fsm_slave_scan.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_slave_scan.c	2023-08-08 19:51:00.935138700 +0800
@@ -274,7 +274,7 @@
 {
     ec_datagram_t *datagram = fsm->datagram;
     ec_slave_t *slave = fsm->slave;
-    u8 octet;
+    U8 octet;
     int i;
 
     if (datagram->state == EC_DATAGRAM_TIMED_OUT && fsm->retries--)
@@ -616,11 +616,11 @@
 alloc_sii:
     if (slave->sii_words) {
         EC_SLAVE_WARN(slave, "Freeing old SII data...\n");
-        kfree(slave->sii_words);
+        PRT_MemFree(OS_MID_SYS, slave->sii_words);
     }
 
     if (!(slave->sii_words =
-                (uint16_t *) kmalloc(slave->sii_nwords * 2, GFP_KERNEL))) {
+                (uint16_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, slave->sii_nwords * 2))) {
         EC_SLAVE_ERR(slave, "Failed to allocate %zu words of SII data.\n",
                slave->sii_nwords);
         slave->sii_nwords = 0;
@@ -717,38 +717,38 @@
                 slave->master->debug_level >= 1) {
             EC_SLAVE_DBG(slave, 1, "Slave announces to support ");
             if (slave->sii.mailbox_protocols & EC_MBOX_AOE) {
-                printk(KERN_CONT "AoE");
+                printf("AoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_COE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    printf(", ");
                 }
-                printk(KERN_CONT "CoE");
+                printf("CoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_FOE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    printf(", ");
                 }
-                printk(KERN_CONT "FoE");
+                printf("FoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_SOE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    printf(", ");
                 }
-                printk(KERN_CONT "SoE");
+                printf("SoE");
                 need_delim = 1;
             }
             if (slave->sii.mailbox_protocols & EC_MBOX_VOE) {
                 if (need_delim) {
-                    printk(KERN_CONT ", ");
+                    printf(", ");
                 }
-                printk(KERN_CONT "VoE");
+                printf("VoE");
                 need_delim = 1;
             }
-            printk(KERN_CONT ".\n");
+            printf(".\n");
         }
         if (slave->sii.mailbox_protocols & ~all) {
             EC_SLAVE_DBG(slave, 1, "Slave announces to support unknown"
diff -urN ethercat-master/master/fsm_soe.c ethercat-master-m/master/fsm_soe.c
--- ethercat-master/master/fsm_soe.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/fsm_soe.c	2023-08-08 19:51:01.193548300 +0800
@@ -200,12 +200,12 @@
     EC_SLAVE_ERR(fsm->slave, "");
 
     if (request->dir == EC_DIR_OUTPUT) {
-        printk(KERN_CONT "Writing");
+        printf("Writing");
     } else {
-        printk(KERN_CONT "Reading");
+        printf("Reading");
     }
 
-    printk(KERN_CONT " IDN 0x%04X failed.\n", request->idn);
+    printf(" IDN 0x%04X failed.\n", request->idn);
 }
 
 /******************************************************************************
@@ -241,7 +241,7 @@
         ec_print_data(data, EC_SOE_SIZE);
     }
 
-    fsm->request->jiffies_sent = jiffies;
+    fsm->request->jiffies_sent = get_jiffies();
     fsm->state = ec_fsm_soe_read_request;
 
     return 0;
@@ -306,7 +306,7 @@
         return;
     }
 
-    diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+    diff_ms = (get_jiffies() - fsm->request->jiffies_sent) * 1000 / HZ;
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -655,7 +655,7 @@
     fsm->offset = 0;
     fsm->retries = EC_FSM_RETRIES;
     ec_fsm_soe_write_next_fragment(fsm, datagram);
-    req->jiffies_sent = jiffies;
+    req->jiffies_sent = get_jiffies();
 }
 
 /*****************************************************************************/
@@ -683,7 +683,7 @@
         return;
     }
 
-    diff_ms = (jiffies - fsm->request->jiffies_sent) * 1000 / HZ;
+    diff_ms = (get_jiffies() - fsm->request->jiffies_sent) * 1000 / HZ;
 
     if (fsm->datagram->working_counter != 1) {
         if (!fsm->datagram->working_counter) {
@@ -708,7 +708,7 @@
         // next fragment
         fsm->retries = EC_FSM_RETRIES;
         ec_fsm_soe_write_next_fragment(fsm, datagram);
-        fsm->request->jiffies_sent = jiffies;
+        fsm->request->jiffies_sent = get_jiffies();
     } else {
         // all fragments sent; query response
         fsm->jiffies_start = fsm->datagram->jiffies_sent;
diff -urN ethercat-master/master/globals.h ethercat-master-m/master/globals.h
--- ethercat-master/master/globals.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/globals.h	2023-08-08 19:51:00.835930900 +0800
@@ -27,12 +27,27 @@
 #ifndef __EC_MASTER_GLOBALS_H__
 #define __EC_MASTER_GLOBALS_H__
 
-#include "../globals.h"
+#include "securec.h"
+#include "prt_config.h"
 #include "../include/ecrt.h"
 
 /******************************************************************************
  * EtherCAT master
  *****************************************************************************/
+#define HZ OS_TICK_PER_SECOND
+
+#define EC_MAX_NUM_SERVICES  1
+
+#define EC_MASTER_VERSION    0
+
+#define ETH_ALEN             6
+#define ETH_TLEN             2
+#define ETH_HLEN             14
+#define ETH_ZLEN             60
+#define ETH_DATA_LEN         1500
+#define ETH_FRAME_LEN        1514
+#define ETH_FCS_LEN          4
+
 
 /** Datagram timeout in microseconds. */
 #define EC_IO_TIMEOUT 500
@@ -210,6 +225,10 @@
 
 /*****************************************************************************/
 
+#define ERR_PTR(err)  ((void *)((long)(err)))
+#define PTR_ERR(ptr)  ((long)(ptr))
+#define IS_ERR(ptr)   ((unsigned long)(ptr) > (unsigned long)(-1000))
+
 /** Convenience macro for printing EtherCAT-specific information to syslog.
  *
  * This will print the message in \a fmt with a prefixed "EtherCAT: ".
@@ -218,7 +237,7 @@
  * \param args arguments (optional)
  */
 #define EC_INFO(fmt, args...) \
-    printk(KERN_INFO "EtherCAT: " fmt, ##args)
+    printf("EtherCAT: " fmt, ##args)
 
 /** Convenience macro for printing EtherCAT-specific errors to syslog.
  *
@@ -228,7 +247,7 @@
  * \param args arguments (optional)
  */
 #define EC_ERR(fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR: " fmt, ##args)
+    printf("EtherCAT ERROR: " fmt, ##args)
 
 /** Convenience macro for printing EtherCAT-specific warnings to syslog.
  *
@@ -238,7 +257,7 @@
  * \param args arguments (optional)
  */
 #define EC_WARN(fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING: " fmt, ##args)
+    printf("EtherCAT WARNING: " fmt, ##args)
 
 /** Convenience macro for printing EtherCAT debug messages to syslog.
  *
@@ -248,7 +267,7 @@
  * \param args arguments (optional)
  */
 #define EC_DBG(fmt, args...) \
-    printk(KERN_DEBUG "EtherCAT DEBUG: " fmt, ##args)
+    printf("EtherCAT DEBUG: " fmt, ##args)
 
 /*****************************************************************************/
 
@@ -317,4 +336,13 @@
 
 /*****************************************************************************/
 
+extern U64 PRT_ClkGetCycleCount64();
+
+static inline uint32_t get_jiffies(void)
+{
+    return PRT_ClkGetCycleCount64() * HZ / OS_SYS_CLOCK;
+}
+
+/*****************************************************************************/
+
 #endif
diff -urN ethercat-master/master/ioctl.c ethercat-master-m/master/ioctl.c
--- ethercat-master/master/ioctl.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/ioctl.c	2023-08-08 19:51:01.025228900 +0800
@@ -1428,7 +1428,7 @@
     ioctl->subindex = req->subindex;
     ioctl->size = req->data_size;
     memcpy(ioctl->data, req->data,
-            min((u32) ioctl->size, (u32) EC_MAX_SDO_DATA_SIZE));
+            min((U32) ioctl->size, (U32) EC_MAX_SDO_DATA_SIZE));
     ioctl->complete_access = req->complete_access;
 
     ec_lock_up(&master->master_sem);
@@ -1493,7 +1493,7 @@
     ioctl->state = req->state;
     ioctl->size = req->data_size;
     memcpy(ioctl->data, req->data,
-            min((u32) ioctl->size, (u32) EC_MAX_IDN_DATA_SIZE));
+            min((U32) ioctl->size, (U32) EC_MAX_IDN_DATA_SIZE));
 
     ec_lock_up(&master->master_sem);
 
@@ -1553,7 +1553,7 @@
         return -EINVAL;
     }
 
-    size = min((u32) strlen(flag->key), (u32) EC_MAX_FLAG_KEY_SIZE - 1);
+    size = min((U32) strlen(flag->key), (U32) EC_MAX_FLAG_KEY_SIZE - 1);
     memcpy(ioctl->key, flag->key, size);
     ioctl->key[size] = 0x00;
     ioctl->value = flag->value;
@@ -3017,7 +3017,7 @@
 {
     ec_ioctl_sc_emerg_t io;
     ec_slave_config_t *sc;
-    u8 msg[EC_COE_EMERGENCY_MSG_SIZE];
+    U8 msg[EC_COE_EMERGENCY_MSG_SIZE];
     int ret;
 
     if (unlikely(!ctx->requested)) {
@@ -4537,7 +4537,7 @@
         )
 {
     ec_ioctl_slave_soe_read_t ioctl;
-    u8 *data;
+    U8 *data;
     int retval;
 
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
@@ -4586,7 +4586,7 @@
         )
 {
     ec_ioctl_slave_soe_write_t ioctl;
-    u8 *data;
+    U8 *data;
     int retval;
 
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
diff -urN ethercat-master/master/locks.h ethercat-master-m/master/locks.h
--- ethercat-master/master/locks.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/locks.h	2023-08-08 19:51:01.151463100 +0800
@@ -38,43 +38,24 @@
 #define __EC_LOCKS_H__
 
 #include "globals.h"
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-#include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
-
-/*****************************************************************************/
-
-#ifdef EC_USE_RTMUTEX
-
-#include <linux/rtmutex.h>
-
-typedef struct rt_mutex ec_lock_t;
-
-static inline void ec_lock_init(ec_lock_t *sem) { rt_mutex_init(sem); }
-static inline void ec_lock_down(ec_lock_t *sem) { rt_mutex_lock(sem); }
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 34)
-static inline int ec_lock_down_interruptible(ec_lock_t *sem) { return rt_mutex_lock_interruptible(sem); }
-#else
-static inline int ec_lock_down_interruptible(ec_lock_t *sem) { return rt_mutex_lock_interruptible(sem, 1); }
-#endif
-static inline void ec_lock_up(ec_lock_t *sem) { rt_mutex_unlock(sem); }
-
-#else
-
-typedef struct semaphore ec_lock_t;
-
-static inline void ec_lock_init(ec_lock_t *sem) { sema_init(sem, 1); }
-static inline void ec_lock_down(ec_lock_t *sem) { down(sem); }
-static inline int ec_lock_down_interruptible(ec_lock_t *sem) { return down_interruptible(sem); }
-static inline void ec_lock_up(ec_lock_t *sem) { up(sem); }
-
-#endif
+#include "pthread.h"
 
 /*****************************************************************************/
+typedef pthread_mutex_t ec_lock_t;
 
-#endif
+static inline void ec_lock_init(ec_lock_t *mutex)
+{
+   pthread_mutex_init(mutex, NULL);
+}
+
+static inline void ec_lock(ec_lock_t *mutex)
+{
+   pthread_mutex_lock(mutex);
+}
+
+static inline void ec_unlock(ec_lock_t *mutex)
+{
+   pthread_mutex_unlock(mutex);
+}
 
-/*****************************************************************************/
+#endif
\ No newline at end of file
diff -urN ethercat-master/master/mailbox.c ethercat-master-m/master/mailbox.c
--- ethercat-master/master/mailbox.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/mailbox.c	2023-08-08 19:51:00.792889700 +0800
@@ -34,9 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-#include <linux/delay.h>
-
 #include "mailbox.h"
 #include "datagram.h"
 #include "master.h"
@@ -57,7 +54,7 @@
     size_t total_size;
     int ret;
 
-    if (unlikely(!slave->sii.mailbox_protocols)) {
+    if (!slave->sii.mailbox_protocols) {
         EC_SLAVE_ERR(slave, "Slave does not support mailbox"
                 " communication!\n");
         return ERR_PTR(-EPROTONOSUPPORT);
@@ -65,7 +62,7 @@
 
     total_size = EC_MBOX_HEADER_SIZE + size;
 
-    if (unlikely(total_size > slave->configured_rx_mailbox_size)) {
+    if (total_size > slave->configured_rx_mailbox_size) {
         EC_SLAVE_ERR(slave, "Data size (%zu) does not fit in mailbox (%u)!\n",
                 total_size, slave->configured_rx_mailbox_size);
         return ERR_PTR(-EOVERFLOW);
@@ -203,13 +200,13 @@
         for (mbox_msg = mbox_error_messages; mbox_msg->code; mbox_msg++) {
             if (mbox_msg->code != code)
                 continue;
-            printk(KERN_CONT "Code 0x%04X: \"%s\".\n",
+            printf("Code 0x%04X: \"%s\".\n",
                     mbox_msg->code, mbox_msg->message);
             break;
         }
 
         if (!mbox_msg->code) {
-            printk(KERN_CONT "Unknown error reply code 0x%04X.\n", code);
+            printf("Unknown error reply code 0x%04X.\n", code);
         }
 
         if (slave->master->debug_level && data_size > 0) {
diff -urN ethercat-master/master/master.c ethercat-master-m/master/master.c
--- ethercat-master/master/master.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/master.c	2023-08-08 19:51:01.137463000 +0800
@@ -34,15 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/version.h>
-#include <linux/hrtimer.h>
-
 #include "globals.h"
 #include "slave.h"
 #include "slave_config.h"
@@ -51,15 +42,13 @@
 #include "mailbox.h"
 
 #ifdef EC_EOE
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
-#include <uapi/linux/sched/types.h> // struct sched_param
-#include <linux/sched/types.h> // sched_setscheduler
-#endif
 #include "ethernet.h"
 #endif
 
 #include "master.h"
 
+#define TASK_INTERRUPTIBLE 0
+
 /*****************************************************************************/
 
 /** Set to 1 to enable external datagram injection debugging.
@@ -337,23 +326,10 @@
     if (ret)
         goto out_clear_sync_mon;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
     master->class_device = device_create(class, NULL,
             MKDEV(MAJOR(device_number), master->index), NULL,
             "EtherCAT%u", master->index);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
-    master->class_device = device_create(class, NULL,
-            MKDEV(MAJOR(device_number), master->index),
-            "EtherCAT%u", master->index);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 15)
-    master->class_device = class_device_create(class, NULL,
-            MKDEV(MAJOR(device_number), master->index), NULL,
-            "EtherCAT%u", master->index);
-#else
-    master->class_device = class_device_create(class,
-            MKDEV(MAJOR(device_number), master->index), NULL,
-            "EtherCAT%u", master->index);
-#endif
+
     if (IS_ERR(master->class_device)) {
         EC_MASTER_ERR(master, "Failed to create class device!\n");
         ret = PTR_ERR(master->class_device);
@@ -372,11 +348,7 @@
 
 #ifdef EC_RTDM
 out_unregister_class_device:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
     device_unregister(master->class_device);
-#else
-    class_device_unregister(master->class_device);
-#endif
 #endif
 out_clear_cdev:
     ec_cdev_clear(&master->cdev);
@@ -415,11 +387,7 @@
     ec_rtdm_dev_clear(&master->rtdm_dev);
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
     device_unregister(master->class_device);
-#else
-    class_device_unregister(master->class_device);
-#endif
 
     ec_cdev_clear(&master->cdev);
 
@@ -459,10 +427,10 @@
 {
     ec_eoe_t *eoe, *next;
 
-    list_for_each_entry_safe(eoe, next, &master->eoe_handlers, list) {
+    list_for_each_entry_safe(eoe, next, ec_eoe_t, &master->eoe_handlers, list) {
         list_del(&eoe->list);
         ec_eoe_clear(eoe);
-        kfree(eoe);
+        PRT_MemFree(OS_MID_SYS, eoe);
     }
 }
 #endif
@@ -478,10 +446,10 @@
     master->dc_ref_config = NULL;
     master->fsm.sdo_request = NULL; // mark sdo_request as invalid
 
-    list_for_each_entry_safe(sc, next, &master->configs, list) {
+    list_for_each_entry_safe(sc, next, ec_slave_config_t, &master->configs, list) {
         list_del(&sc->list);
         ec_slave_config_clear(sc);
-        kfree(sc);
+        PRT_MemFree(OS_MID_SYS, sc);
     }
 }
 
@@ -520,7 +488,7 @@
     }
 
     if (master->slaves) {
-        kfree(master->slaves);
+        PRT_MemFree(OS_MID_SYS, master->slaves);
         master->slaves = NULL;
     }
 
@@ -535,13 +503,13 @@
 {
     ec_domain_t *domain, *next;
 
-    ec_lock_down(&master->domains_lock);
-    list_for_each_entry_safe(domain, next, &master->domains, list) {
+    ec_lock(&master->domains_lock);
+    list_for_each_entry_safe(domain, next, ec_domain_t, &master->domains, list) {
         list_del(&domain->list);
         ec_domain_clear(domain);
-        kfree(domain);
+        PRT_MemFree(OS_MID_SYS, domain);
     }
-    ec_lock_up(&master->domains_lock);
+    ec_unlock(&master->domains_lock);
 }
 
 /*****************************************************************************/
@@ -552,10 +520,10 @@
         ec_master_t *master /**< EtherCAT master. */
         )
 {
-    ec_lock_down(&master->master_sem);
+    ec_lock(&master->master_sem);
     ec_master_clear_domains(master);
     ec_master_clear_slave_configs(master);
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 }
 
 /*****************************************************************************/
@@ -688,9 +656,9 @@
 #endif
     ec_master_thread_stop(master);
 
-    ec_lock_down(&master->master_sem);
+    ec_lock(&master->master_sem);
     ec_master_clear_slaves(master);
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     ec_fsm_master_reset(&master->fsm);
 }
@@ -710,9 +678,9 @@
 
     EC_MASTER_DBG(master, 1, "IDLE -> OPERATION.\n");
 
-    ec_lock_down(&master->config_sem);
+    ec_lock(&master->config_sem);
     if (master->config_busy) {
-        ec_lock_up(&master->config_sem);
+        ec_unlock(&master->config_sem);
 
         // wait for slave configuration to complete
         ret = wait_event_interruptible(master->config_queue,
@@ -726,15 +694,15 @@
         EC_MASTER_DBG(master, 1, "Waiting for pending slave"
                 " configuration returned.\n");
     } else {
-        ec_lock_up(&master->config_sem);
+        ec_unlock(&master->config_sem);
     }
 
-    ec_lock_down(&master->scan_sem);
+    ec_lock(&master->scan_sem);
     master->allow_scan = 0; // 'lock' the slave list
     if (!master->scan_busy) {
-        ec_lock_up(&master->scan_sem);
+        ec_unlock(&master->scan_sem);
     } else {
-        ec_lock_up(&master->scan_sem);
+        ec_unlock(&master->scan_sem);
 
         // wait for slave scan to complete
         ret = wait_event_interruptible(master->scan_queue,
@@ -809,7 +777,7 @@
         return;
     }
 
-    list_for_each_entry(datagram, &master->datagram_queue, queue) {
+    list_for_each_entry(datagram, ec_datagram_t, &master->datagram_queue, queue) {
         if (datagram->state == EC_DATAGRAM_QUEUED) {
             queue_size += datagram->data_size;
         }
@@ -859,7 +827,7 @@
             if (cycles_now - datagram->cycles_sent
                     > ext_injection_timeout_cycles)
 #else
-            if (jiffies - datagram->jiffies_sent
+            if (get_jiffies() - datagram->jiffies_sent
                     > ext_injection_timeout_jiffies)
 #endif
             {
@@ -876,7 +844,7 @@
                     / cpu_khz;
 #else
                 time_us = (unsigned int)
-                    ((jiffies - datagram->jiffies_sent) * 1000000 / HZ);
+                    ((get_jiffies() - datagram->jiffies_sent) * 1000000 / HZ);
 #endif
                 EC_MASTER_ERR(master, "Timeout %u us: Injecting"
                         " external datagram %s size=%zu,"
@@ -957,7 +925,7 @@
      * the datagram is queued to avoid duplicate queuing (which results in an
      * infinite loop!). Set the state to EC_DATAGRAM_QUEUED again, probably
      * causing an unmatched datagram. */
-    list_for_each_entry(queued_datagram, &master->datagram_queue, queue) {
+    list_for_each_entry(queued_datagram, ec_datagram_t, &master->datagram_queue, queue) {
         if (queued_datagram == datagram) {
             datagram->skip_count++;
 #ifdef EC_RT_SYSLOG
@@ -984,9 +952,9 @@
         ec_datagram_t *datagram /**< datagram */
         )
 {
-    ec_lock_down(&master->ext_queue_sem);
+    ec_lock(&master->ext_queue_sem);
     list_add_tail(&datagram->queue, &master->ext_datagram_queue);
-    ec_lock_up(&master->ext_queue_sem);
+    ec_unlock(&master->ext_queue_sem);
 }
 
 /*****************************************************************************/
@@ -994,7 +962,7 @@
 static int index_in_use(ec_master_t *master, uint8_t index)
 {
     ec_datagram_t *datagram;
-    list_for_each_entry(datagram, &master->datagram_queue, queue)
+    list_for_each_entry(datagram, ec_datagram_t, &master->datagram_queue, queue)
         if (datagram->state == EC_DATAGRAM_SENT && datagram->index == index)
             return 1;
     return 0;
@@ -1036,7 +1004,7 @@
         more_datagrams_waiting = 0;
 
         // fill current frame with datagrams
-        list_for_each_entry(datagram, &master->datagram_queue, queue) {
+        list_for_each_entry(datagram, ec_datagram_t, &master->datagram_queue, queue) {
             if (datagram->state != EC_DATAGRAM_QUEUED ||
                     datagram->device_index != device_index) {
                 continue;
@@ -1121,10 +1089,10 @@
 #ifdef EC_HAVE_CYCLES
         cycles_sent = get_cycles();
 #endif
-        jiffies_sent = jiffies;
+        jiffies_sent = get_jiffies();
 
         // set datagram states and sending timestamps
-        list_for_each_entry_safe(datagram, next, &sent_datagrams, sent) {
+        list_for_each_entry_safe(datagram, next, ec_datagram_t, &sent_datagrams, sent) {
             datagram->state = EC_DATAGRAM_SENT;
 #ifdef EC_HAVE_CYCLES
             datagram->cycles_sent = cycles_sent;
@@ -1139,7 +1107,7 @@
     while (more_datagrams_waiting && frame_count < EC_TX_RING_SIZE);
 
 #ifdef EC_HAVE_CYCLES
-    if (unlikely(master->debug_level > 1)) {
+    if (master->debug_level > 1) {
         cycles_end = get_cycles();
         EC_MASTER_DBG(master, 0, "%s()"
                 " sent %u frames in %uus.\n", __func__, frame_count,
@@ -1174,7 +1142,7 @@
     ec_datagram_t *datagram;
     ec_slave_t *slave;
 
-    if (unlikely(size < EC_FRAME_HEADER_SIZE)) {
+    if (size < EC_FRAME_HEADER_SIZE) {
         if (master->debug_level || FORCE_OUTPUT_CORRUPTED) {
             EC_MASTER_DBG(master, 0, "Corrupted frame received"
                     " on %s (size %zu < %u byte):\n",
@@ -1194,7 +1162,7 @@
     frame_size = EC_READ_U16(cur_data) & 0x07FF;
     cur_data += EC_FRAME_HEADER_SIZE;
 
-    if (unlikely(frame_size > size)) {
+    if (frame_size > size) {
         if (master->debug_level || FORCE_OUTPUT_CORRUPTED) {
             EC_MASTER_DBG(master, 0, "Corrupted frame received"
                     " on %s (invalid frame size %zu for "
@@ -1220,8 +1188,8 @@
         cmd_follows    = EC_READ_U16(cur_data + 6) & 0x8000;
         cur_data += EC_DATAGRAM_HEADER_SIZE;
 
-        if (unlikely(cur_data - frame_data
-                     + data_size + EC_DATAGRAM_FOOTER_SIZE > size)) {
+        if (cur_data - frame_data
+                     + data_size + EC_DATAGRAM_FOOTER_SIZE > size) {
             if (master->debug_level || FORCE_OUTPUT_CORRUPTED) {
                 EC_MASTER_DBG(master, 0, "Corrupted frame received"
                         " on %s (invalid data size %zu):\n",
@@ -1237,7 +1205,7 @@
 
         // search for matching datagram in the queue
         matched = 0;
-        list_for_each_entry(datagram, &master->datagram_queue, queue) {
+        list_for_each_entry(datagram, ec_datagram_t, &master->datagram_queue, queue) {
             if (datagram->index == datagram_index
                 && datagram->state == EC_DATAGRAM_SENT
                 && datagram->type == datagram_type
@@ -1254,7 +1222,7 @@
             ec_master_output_stats(master);
 #endif
 
-            if (unlikely(master->debug_level > 0)) {
+            if (master->debug_level > 0) {
                 EC_MASTER_DBG(master, 0, "UNMATCHED datagram:\n");
                 ec_print_data(cur_data - EC_DATAGRAM_HEADER_SIZE,
                         EC_DATAGRAM_HEADER_SIZE + data_size
@@ -1403,8 +1371,8 @@
  */
 void ec_master_output_stats(ec_master_t *master /**< EtherCAT master */)
 {
-    if (unlikely(jiffies - master->stats.output_jiffies >= HZ)) {
-        master->stats.output_jiffies = jiffies;
+    if (get_jiffies() - master->stats.output_jiffies >= HZ) {
+        master->stats.output_jiffies = get_jiffies();
 
         if (master->stats.timeouts) {
             EC_MASTER_WARN(master, "%u datagram%s TIMED OUT!\n",
@@ -1468,12 +1436,12 @@
         )
 {
     ec_device_stats_t *s = &master->device_stats;
-    s32 tx_frame_rate, rx_frame_rate, tx_byte_rate, rx_byte_rate, loss_rate;
-    u64 loss;
+    S32 tx_frame_rate, rx_frame_rate, tx_byte_rate, rx_byte_rate, loss_rate;
+    U64 loss;
     unsigned int i, dev_idx;
 
     // frame statistics
-    if (likely(jiffies - s->jiffies < HZ)) {
+    if (likely(get_jiffies() - s->jiffies < HZ)) {
         return;
     }
 
@@ -1489,7 +1457,7 @@
      *   -> Y_n += (x - y_(n - 1)) / tau
      */
     for (i = 0; i < EC_RATE_COUNT; i++) {
-        s32 n = rate_intervals[i];
+        S32 n = rate_intervals[i];
         s->tx_frame_rates[i] += (tx_frame_rate - s->tx_frame_rates[i]) / n;
         s->rx_frame_rates[i] += (rx_frame_rate - s->rx_frame_rates[i]) / n;
         s->tx_byte_rates[i] += (tx_byte_rate - s->tx_byte_rates[i]) / n;
@@ -1508,7 +1476,7 @@
         ec_device_update_stats(&master->devices[dev_idx]);
     }
 
-    s->jiffies = jiffies;
+    s->jiffies = get_jiffies();
 }
 
 /*****************************************************************************/
@@ -1598,7 +1566,7 @@
     ec_fsm_slave_t *fsm, *next;
     unsigned int count = 0;
 
-    list_for_each_entry_safe(fsm, next, &master->fsm_exec_list, list) {
+    list_for_each_entry_safe(fsm, next, ec_fsm_slave_t, &master->fsm_exec_list, list) {
         if (!fsm->datagram) {
             EC_MASTER_WARN(master, "Slave %u FSM has zero datagram."
                     "This is a bug!\n", fsm->slave->ring_position);
@@ -1697,9 +1665,9 @@
         ec_datagram_output_stats(&master->fsm_datagram);
 
         // receive
-        ec_lock_down(&master->io_sem);
+        ec_lock(&master->io_sem);
         ecrt_master_receive(master);
-        ec_lock_up(&master->io_sem);
+        ec_unlock(&master->io_sem);
 
         // execute master & slave state machines
         if (ec_lock_down_interruptible(&master->master_sem)) {
@@ -1710,15 +1678,15 @@
 
         ec_master_exec_slave_fsms(master);
 
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
 
         // queue and send
-        ec_lock_down(&master->io_sem);
+        ec_lock(&master->io_sem);
         if (fsm_exec) {
             ec_master_queue_datagram(master, &master->fsm_datagram);
         }
         sent_bytes = ecrt_master_send(master);
-        ec_lock_up(&master->io_sem);
+        ec_unlock(&master->io_sem);
 
         if (ec_fsm_master_idle(&master->fsm)) {
 #ifdef EC_USE_HRTIMER
@@ -1774,7 +1742,7 @@
 
             ec_master_exec_slave_fsms(master);
 
-            ec_lock_up(&master->master_sem);
+            ec_unlock(&master->master_sem);
         }
 
 #ifdef EC_USE_HRTIMER
@@ -1877,7 +1845,7 @@
         none_open = 1;
         all_idle = 1;
 
-        list_for_each_entry(eoe, &master->eoe_handlers, list) {
+        list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
             if (ec_eoe_is_open(eoe)) {
                 none_open = 0;
                 break;
@@ -1888,13 +1856,13 @@
         }
 
         // receive datagrams
-	ec_lock_down(&master->io_sem);
+	ec_lock(&master->io_sem);
         master->receive_cb(master->cb_data);
-	ec_lock_up(&master->io_sem);
+	ec_unlock(&master->io_sem);
 
         // actual EoE processing
         sth_to_send = 0;
-        list_for_each_entry(eoe, &master->eoe_handlers, list) {
+        list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
             ec_eoe_run(eoe);
             if (eoe->queue_datagram) {
                 sth_to_send = 1;
@@ -1905,15 +1873,15 @@
         }
 
         if (sth_to_send) {
-	    ec_lock_down(&master->io_sem);
-            list_for_each_entry(eoe, &master->eoe_handlers, list) {
+	    ec_lock(&master->io_sem);
+            list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
                 ec_eoe_queue(eoe);
             }
-	    ec_lock_up(&master->io_sem);
+	    ec_unlock(&master->io_sem);
             // (try to) send datagrams
-            ec_lock_down(&master->ext_queue_sem);
+            ec_lock(&master->ext_queue_sem);
             master->send_cb(master->cb_data);
-            ec_lock_up(&master->ext_queue_sem);
+            ec_unlock(&master->ext_queue_sem);
         }
 
 schedule:
@@ -1941,7 +1909,7 @@
 {
     ec_slave_config_t *sc;
 
-    list_for_each_entry(sc, &master->configs, list) {
+    list_for_each_entry(sc, ec_slave_config_t, &master->configs, list) {
         ec_slave_config_attach(sc);
     }
 }
@@ -1956,7 +1924,7 @@
 {
     ec_slave_config_t *sc;
 
-    list_for_each_entry(sc, &master->configs, list) {
+    list_for_each_entry(sc, ec_slave_config_t, &master->configs, list) {
         ec_slave_config_expire_disconnected_requests(sc);
     }
 }
@@ -2029,7 +1997,7 @@
     const ec_slave_config_t *sc;
     unsigned int count = 0;
 
-    list_for_each_entry(sc, &master->configs, list) {
+    list_for_each_entry(sc, ec_slave_config_t, &master->configs, list) {
         count++;
     }
 
@@ -2041,9 +2009,9 @@
 /** Common implementation for ec_master_get_config()
  * and ec_master_get_config_const().
  */
-#define EC_FIND_CONFIG \
+#define EC_FIND_CONFIG(type) \
     do { \
-        list_for_each_entry(sc, &master->configs, list) { \
+        list_for_each_entry(sc, type, &master->configs, list) { \
             if (pos--) \
                 continue; \
             return sc; \
@@ -2061,7 +2029,7 @@
         )
 {
     ec_slave_config_t *sc;
-    EC_FIND_CONFIG;
+    EC_FIND_CONFIG(ec_slave_config_t);
 }
 
 /** Get a slave configuration via its position in the list.
@@ -2076,7 +2044,7 @@
         )
 {
     const ec_slave_config_t *sc;
-    EC_FIND_CONFIG;
+    EC_FIND_CONFIG(ec_slave_config_t);
 }
 
 /*****************************************************************************/
@@ -2092,11 +2060,11 @@
     const ec_domain_t *domain;
     unsigned int count = 0;
 
-    ec_lock_down(&master->domains_lock);
-    list_for_each_entry(domain, &master->domains, list) {
+    ec_lock(&master->domains_lock);
+    list_for_each_entry(domain, ec_domain_t, &master->domains, list) {
         count++;
     }
-    ec_lock_up(&master->domains_lock);
+    ec_unlock(&master->domains_lock);
 
     return count;
 }
@@ -2106,9 +2074,9 @@
 /** Common implementation for ec_master_find_domain() and
  * ec_master_find_domain_const().
  */
-#define EC_FIND_DOMAIN \
+#define EC_FIND_DOMAIN(type) \
     do { \
-        list_for_each_entry(domain, &master->domains, list) { \
+        list_for_each_entry(domain, type, &master->domains, list) { \
             if (index--) \
                 continue; \
             return domain; \
@@ -2127,7 +2095,7 @@
         )
 {
     ec_domain_t *domain;
-    EC_FIND_DOMAIN;
+    EC_FIND_DOMAIN(ec_domain_t);
 }
 
 /** Get a domain via its position in the list.
@@ -2142,7 +2110,7 @@
         )
 {
     const ec_domain_t *domain;
-    EC_FIND_DOMAIN;
+    EC_FIND_DOMAIN(ec_domain_t);
 }
 
 /*****************************************************************************/
@@ -2160,7 +2128,7 @@
     const ec_eoe_t *eoe;
     unsigned int count = 0;
 
-    list_for_each_entry(eoe, &master->eoe_handlers, list) {
+    list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
         count++;
     }
 
@@ -2182,7 +2150,7 @@
 {
     const ec_eoe_t *eoe;
 
-    list_for_each_entry(eoe, &master->eoe_handlers, list) {
+    list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
         if (index--)
             continue;
         return eoe;
@@ -2437,12 +2405,12 @@
             master);
 
     if (!(domain =
-                (ec_domain_t *) kmalloc(sizeof(ec_domain_t), GFP_KERNEL))) {
+                (ec_domain_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_domain_t)))) {
         EC_MASTER_ERR(master, "Error allocating domain memory!\n");
         return ERR_PTR(-ENOMEM);
     }
 
-    ec_lock_down(&master->domains_lock);
+    ec_lock(&master->domains_lock);
 
     if (list_empty(&master->domains)) {
         index = 0;
@@ -2454,7 +2422,7 @@
     ec_domain_init(domain, master, index);
     list_add_tail(&domain->list, &master->domains);
 
-    ec_lock_up(&master->domains_lock);
+    ec_unlock(&master->domains_lock);
 
     EC_MASTER_DBG(master, 1, "Created domain %u.\n", domain->index);
 
@@ -2497,21 +2465,21 @@
         return 0;
     }
 
-    ec_lock_down(&master->domains_lock);
+    ec_lock(&master->domains_lock);
 
     // finish all domains
     domain_offset = 0;
-    list_for_each_entry(domain, &master->domains, list) {
+    list_for_each_entry(domain, ec_domain_t, &master->domains, list) {
         ret = ec_domain_finish(domain, domain_offset);
         if (ret < 0) {
-            ec_lock_up(&master->domains_lock);
+            ec_unlock(&master->domains_lock);
             EC_MASTER_ERR(master, "Failed to finish domain 0x%p!\n", domain);
             return ret;
         }
         domain_offset += domain->data_size;
     }
 
-    ec_lock_up(&master->domains_lock);
+    ec_unlock(&master->domains_lock);
 
     // restart EoE process and master thread with new locking
 
@@ -2573,7 +2541,7 @@
 
 
     // clear dc settings on all slaves
-    list_for_each_entry_safe(sc, next, &master->configs, list) {
+    list_for_each_entry_safe(sc, next, ec_slave_config_t, &master->configs, list) {
         if (sc->dc_assign_activate) {
             ecrt_slave_config_dc(sc, 0x0000, 0, 0, 0, 0);
         }
@@ -2595,7 +2563,7 @@
 
 #ifdef EC_EOE
     // ... but leave EoE slaves in OP
-    list_for_each_entry(eoe, &master->eoe_handlers, list) {
+    list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
         if (ec_eoe_is_open(eoe))
             ec_slave_request_state(eoe->slave, EC_SLAVE_STATE_OP);
     }
@@ -2650,7 +2618,7 @@
 
 #ifdef EC_EOE
     // ... but leave EoE slaves in OP
-    list_for_each_entry(eoe, &master->eoe_handlers, list) {
+    list_for_each_entry(eoe, ec_eoe_t, &master->eoe_handlers, list) {
         if (ec_eoe_is_open(eoe))
             ec_slave_request_state(eoe->slave, EC_SLAVE_STATE_OP);
     }
@@ -2696,9 +2664,9 @@
 
     for (dev_idx = EC_DEVICE_MAIN; dev_idx < ec_master_num_devices(master);
             dev_idx++) {
-        if (unlikely(!master->devices[dev_idx].link_state)) {
+        if (!master->devices[dev_idx].link_state) {
             // link is down, no datagram can be sent
-            list_for_each_entry_safe(datagram, n,
+            list_for_each_entry_safe(datagram, n, ec_datagram_t,
                     &master->datagram_queue, queue) {
                 if (datagram->device_index == dev_idx) {
                     datagram->state = EC_DATAGRAM_ERROR;
@@ -2741,7 +2709,7 @@
     ec_master_update_device_stats(master);
 
     // dequeue all datagrams that timed out
-    list_for_each_entry_safe(datagram, next, &master->datagram_queue, queue) {
+    list_for_each_entry_safe(datagram, next, ec_datagram_t, &master->datagram_queue, queue) {
         if (datagram->state != EC_DATAGRAM_SENT) continue;
 
 #ifdef EC_HAVE_CYCLES
@@ -2758,7 +2726,7 @@
 #ifdef EC_RT_SYSLOG
             ec_master_output_stats(master);
 
-            if (unlikely(master->debug_level > 0)) {
+            if (master->debug_level > 0) {
                 unsigned int time_us;
 #ifdef EC_HAVE_CYCLES
                 time_us = (unsigned int)
@@ -2784,7 +2752,7 @@
 {
     ec_datagram_t *datagram, *next;
 
-    list_for_each_entry_safe(datagram, next, &master->ext_datagram_queue,
+    list_for_each_entry_safe(datagram, next, ec_datagram_t, &master->ext_datagram_queue,
             queue) {
         list_del(&datagram->queue);
         ec_master_queue_datagram(master, datagram);
@@ -2810,7 +2778,7 @@
             " product_code = 0x%08x)\n",
             master, alias, position, vendor_id, product_code);
 
-    list_for_each_entry(sc, &master->configs, list) {
+    list_for_each_entry(sc, ec_slave_config_t, &master->configs, list) {
         if (sc->alias == alias && sc->position == position) {
             found = 1;
             break;
@@ -2830,8 +2798,7 @@
                 " 0x%08X/0x%08X.\n",
                 alias, position, vendor_id, product_code);
 
-        if (!(sc = (ec_slave_config_t *) kmalloc(sizeof(ec_slave_config_t),
-                        GFP_KERNEL))) {
+        if (!(sc = (ec_slave_config_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_slave_config_t)))) {
             EC_MASTER_ERR(master, "Failed to allocate memory"
                     " for slave configuration.\n");
             return ERR_PTR(-ENOMEM);
@@ -2840,14 +2807,14 @@
         ec_slave_config_init(sc, master,
                 alias, position, vendor_id, product_code);
 
-        ec_lock_down(&master->master_sem);
+        ec_lock(&master->master_sem);
 
         // try to find the addressed slave
         ec_slave_config_attach(sc);
         ec_slave_config_load_default_sync_config(sc);
         list_add_tail(&sc->list, &master->configs);
 
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
     }
 
     return sc;
@@ -2959,7 +2926,7 @@
     }
 
 out_get_slave:
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     return ret;
 }
@@ -3023,7 +2990,7 @@
 {
     master->app_time = app_time;
 
-    if (unlikely(!master->dc_ref_time)) {
+    if (!master->dc_ref_time) {
         master->dc_ref_time = app_time;
     }
 }
@@ -3170,7 +3137,7 @@
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         ec_sdo_request_clear(&request);
         return -EINVAL;
@@ -3181,21 +3148,21 @@
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        ec_lock_down(&master->master_sem);
+        ec_lock(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            ec_lock_up(&master->master_sem);
+            ec_unlock(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3205,8 +3172,8 @@
 
     if (request.state == EC_INT_REQUEST_SUCCESS) {
         ret = 0;
-    } else if (request.errno) {
-        ret = -request.errno;
+    } else if (request.err_no) {
+        ret = -request.err_no;
     } else {
         ret = -EIO;
     }
@@ -3250,7 +3217,7 @@
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         ec_sdo_request_clear(&request);
         return -EINVAL;
@@ -3262,21 +3229,21 @@
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        ec_lock_down(&master->master_sem);
+        ec_lock(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            ec_lock_up(&master->master_sem);
+            ec_unlock(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3286,8 +3253,8 @@
 
     if (request.state == EC_INT_REQUEST_SUCCESS) {
         ret = 0;
-    } else if (request.errno) {
-        ret = -request.errno;
+    } else if (request.err_no) {
+        ret = -request.err_no;
     } else {
         ret = -EIO;
     }
@@ -3323,7 +3290,7 @@
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
         ec_sdo_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         return -EINVAL;
@@ -3334,21 +3301,21 @@
     // schedule request.
     list_add_tail(&request.list, &slave->sdo_requests);
 
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        ec_lock_down(&master->master_sem);
+        ec_lock(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            ec_lock_up(&master->master_sem);
+            ec_unlock(&master->master_sem);
             ec_sdo_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3358,8 +3325,8 @@
 
     if (request.state != EC_INT_REQUEST_SUCCESS) {
         *result_size = 0;
-        if (request.errno) {
-            ret = -request.errno;
+        if (request.err_no) {
+            ret = -request.err_no;
         } else {
             ret = -EIO;
         }
@@ -3414,7 +3381,7 @@
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n",
                 slave_position);
         ec_soe_request_clear(&request);
@@ -3426,21 +3393,21 @@
     // schedule SoE write request.
     list_add_tail(&request.list, &slave->soe_requests);
 
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        ec_lock_down(&master->master_sem);
+        ec_lock(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             // abort request
             list_del(&request.list);
-            ec_lock_up(&master->master_sem);
+            ec_unlock(&master->master_sem);
             ec_soe_request_clear(&request);
             return -EINTR;
         }
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3481,7 +3448,7 @@
     }
 
     if (!(slave = ec_master_find_slave(master, 0, slave_position))) {
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
         ec_soe_request_clear(&request);
         EC_MASTER_ERR(master, "Slave %u does not exist!\n", slave_position);
         return -EINVAL;
@@ -3492,21 +3459,21 @@
     // schedule request.
     list_add_tail(&request.list, &slave->soe_requests);
 
-    ec_lock_up(&master->master_sem);
+    ec_unlock(&master->master_sem);
 
     // wait for processing through FSM
     if (wait_event_interruptible(master->request_queue,
                 request.state != EC_INT_REQUEST_QUEUED)) {
         // interrupted by signal
-        ec_lock_down(&master->master_sem);
+        ec_lock(&master->master_sem);
         if (request.state == EC_INT_REQUEST_QUEUED) {
             list_del(&request.list);
-            ec_lock_up(&master->master_sem);
+            ec_unlock(&master->master_sem);
             ec_soe_request_clear(&request);
             return -EINTR;
         }
         // request already processing: interrupt not possible.
-        ec_lock_up(&master->master_sem);
+        ec_unlock(&master->master_sem);
     }
 
     // wait until master FSM has finished processing
@@ -3545,7 +3512,7 @@
 {
     ec_slave_config_t *sc;
 
-    list_for_each_entry(sc, &master->configs, list) {
+    list_for_each_entry(sc, ec_slave_config_t, &master->configs, list) {
         if (sc->slave) {
             ec_slave_request_state(sc->slave, EC_SLAVE_STATE_OP);
         }
@@ -3553,40 +3520,3 @@
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecrt_master_create_domain);
-EXPORT_SYMBOL(ecrt_master_setup_domain_memory);
-EXPORT_SYMBOL(ecrt_master_activate);
-EXPORT_SYMBOL(ecrt_master_deactivate_slaves);
-EXPORT_SYMBOL(ecrt_master_deactivate);
-EXPORT_SYMBOL(ecrt_master_send);
-EXPORT_SYMBOL(ecrt_master_send_ext);
-EXPORT_SYMBOL(ecrt_master_receive);
-EXPORT_SYMBOL(ecrt_master_callbacks);
-EXPORT_SYMBOL(ecrt_master);
-EXPORT_SYMBOL(ecrt_master_get_slave);
-EXPORT_SYMBOL(ecrt_master_slave_config);
-EXPORT_SYMBOL(ecrt_master_select_reference_clock);
-EXPORT_SYMBOL(ecrt_master_state);
-EXPORT_SYMBOL(ecrt_master_link_state);
-EXPORT_SYMBOL(ecrt_master_application_time);
-EXPORT_SYMBOL(ecrt_master_sync_reference_clock);
-EXPORT_SYMBOL(ecrt_master_sync_reference_clock_to);
-EXPORT_SYMBOL(ecrt_master_sync_slave_clocks);
-EXPORT_SYMBOL(ecrt_master_reference_clock_time);
-EXPORT_SYMBOL(ecrt_master_64bit_reference_clock_time_queue);
-EXPORT_SYMBOL(ecrt_master_64bit_reference_clock_time);
-EXPORT_SYMBOL(ecrt_master_sync_monitor_queue);
-EXPORT_SYMBOL(ecrt_master_sync_monitor_process);
-EXPORT_SYMBOL(ecrt_master_sdo_download);
-EXPORT_SYMBOL(ecrt_master_sdo_download_complete);
-EXPORT_SYMBOL(ecrt_master_sdo_upload);
-EXPORT_SYMBOL(ecrt_master_write_idn);
-EXPORT_SYMBOL(ecrt_master_read_idn);
-EXPORT_SYMBOL(ecrt_master_reset);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/master.h ethercat-master-m/master/master.h
--- ethercat-master/master/master.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/master.h	2023-08-08 19:51:00.878033800 +0800
@@ -37,12 +37,6 @@
 #ifndef __EC_MASTER_H__
 #define __EC_MASTER_H__
 
-#include <linux/version.h>
-#include <linux/list.h>
-#include <linux/timer.h>
-#include <linux/wait.h>
-#include <linux/kthread.h>
-
 #include "device.h"
 #include "domain.h"
 #include "ethernet.h"
@@ -66,7 +60,7 @@
  * \param args arguments (optional)
  */
 #define EC_MASTER_INFO(master, fmt, args...) \
-    printk(KERN_INFO "EtherCAT %u: " fmt, master->index, ##args)
+    printf("EtherCAT %u: " fmt, master->index, ##args)
 
 /** Convenience macro for printing master-specific errors to syslog.
  *
@@ -78,7 +72,7 @@
  * \param args arguments (optional)
  */
 #define EC_MASTER_ERR(master, fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR %u: " fmt, master->index, ##args)
+    printf("EtherCAT ERROR %u: " fmt, master->index, ##args)
 
 /** Convenience macro for printing master-specific warnings to syslog.
  *
@@ -90,7 +84,7 @@
  * \param args arguments (optional)
  */
 #define EC_MASTER_WARN(master, fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING %u: " fmt, master->index, ##args)
+    printf("EtherCAT WARNING %u: " fmt, master->index, ##args)
 
 /** Convenience macro for printing master-specific debug messages to syslog.
  *
@@ -106,7 +100,7 @@
 #define EC_MASTER_DBG(master, level, fmt, args...) \
     do { \
         if (master->debug_level >= level) { \
-            printk(KERN_DEBUG "EtherCAT DEBUG %u: " fmt, \
+            printf("EtherCAT DEBUG %u: " fmt, \
                     master->index, ##args); \
         } \
     } while (0)
@@ -148,28 +142,28 @@
 /** Device statistics.
  */
 typedef struct {
-    u64 tx_count; /**< Number of frames sent. */
-    u64 last_tx_count; /**< Number of frames sent of last statistics cycle. */
-    u64 rx_count; /**< Number of frames received. */
-    u64 last_rx_count; /**< Number of frames received of last statistics
+    U64 tx_count; /**< Number of frames sent. */
+    U64 last_tx_count; /**< Number of frames sent of last statistics cycle. */
+    U64 rx_count; /**< Number of frames received. */
+    U64 last_rx_count; /**< Number of frames received of last statistics
                          cycle. */
-    u64 tx_bytes; /**< Number of bytes sent. */
-    u64 last_tx_bytes; /**< Number of bytes sent of last statistics cycle. */
-    u64 rx_bytes; /**< Number of bytes received. */
-    u64 last_rx_bytes; /**< Number of bytes received of last statistics cycle.
+    U64 tx_bytes; /**< Number of bytes sent. */
+    U64 last_tx_bytes; /**< Number of bytes sent of last statistics cycle. */
+    U64 rx_bytes; /**< Number of bytes received. */
+    U64 last_rx_bytes; /**< Number of bytes received of last statistics cycle.
                         */
-    u64 last_loss; /**< Tx/Rx difference of last statistics cycle. */
-    s32 tx_frame_rates[EC_RATE_COUNT]; /**< Transmit rates in frames/s for
+    U64 last_loss; /**< Tx/Rx difference of last statistics cycle. */
+    S32 tx_frame_rates[EC_RATE_COUNT]; /**< Transmit rates in frames/s for
                                          different statistics cycle periods.
                                         */
-    s32 rx_frame_rates[EC_RATE_COUNT]; /**< Receive rates in frames/s for
+    S32 rx_frame_rates[EC_RATE_COUNT]; /**< Receive rates in frames/s for
                                          different statistics cycle periods.
                                         */
-    s32 tx_byte_rates[EC_RATE_COUNT]; /**< Transmit rates in byte/s for
+    S32 tx_byte_rates[EC_RATE_COUNT]; /**< Transmit rates in byte/s for
                                         different statistics cycle periods. */
-    s32 rx_byte_rates[EC_RATE_COUNT]; /**< Receive rates in byte/s for
+    S32 rx_byte_rates[EC_RATE_COUNT]; /**< Receive rates in byte/s for
                                         different statistics cycle periods. */
-    s32 loss_rates[EC_RATE_COUNT]; /**< Frame loss rates for different
+    S32 loss_rates[EC_RATE_COUNT]; /**< Frame loss rates for different
                                      statistics cycle periods. */
     unsigned long jiffies; /**< Jiffies of last statistic cycle. */
 } ec_device_stats_t;
@@ -191,11 +185,7 @@
     unsigned int reserved; /**< \a True, if the master is in use. */
 
     ec_cdev_t cdev; /**< Master character device. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
     struct device *class_device; /**< Master class device. */
-#else
-    struct class_device *class_device; /**< Master class device. */
-#endif
 
 #ifdef EC_RTDM
     ec_rtdm_dev_t rtdm_dev; /**< RTDM device. */
@@ -231,9 +221,9 @@
     struct list_head domains; /**< List of domains. */
     ec_lock_t domains_lock; /**< Lock for access to domains list. */
 
-    u64 app_time; /**< Time of the last ecrt_master_sync() call. */
-    u64 dc_ref_time; /**< Common reference timestamp for DC start times. */
-    u8 dc_offset_valid; /**< DC slaves have valid system time offsets*/
+    U64 app_time; /**< Time of the last ecrt_master_sync() call. */
+    U64 dc_ref_time; /**< Common reference timestamp for DC start times. */
+    U8 dc_offset_valid; /**< DC slaves have valid system time offsets*/
     ec_datagram_t ref_sync_datagram; /**< Datagram used for synchronizing the
                                        reference clock to the master clock. */
     ec_datagram_t sync_datagram; /**< Datagram used for DC drift
diff -urN ethercat-master/master/module.c ethercat-master-m/master/module.c
--- ethercat-master/master/module.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/module.c	2023-08-08 19:51:00.709689000 +0800
@@ -33,10 +33,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/err.h>
-
 #include "globals.h"
 #include "master.h"
 #include "device.h"
@@ -47,8 +43,8 @@
 
 /*****************************************************************************/
 
-int __init ec_init_module(void);
-void __exit ec_cleanup_module(void);
+int ec_init_module(void);
+void ec_cleanup_module(void);
 
 static int ec_mac_parse(uint8_t *, const char *, int);
 
@@ -72,30 +68,12 @@
 
 /*****************************************************************************/
 
-/** \cond */
-
-MODULE_AUTHOR("Florian Pose <fp@igh-essen.com>");
-MODULE_DESCRIPTION("EtherCAT master driver module");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(EC_MASTER_VERSION);
-
-module_param_array(main_devices, charp, &master_count, S_IRUGO);
-MODULE_PARM_DESC(main_devices, "MAC addresses of main devices");
-module_param_array(backup_devices, charp, &backup_count, S_IRUGO);
-MODULE_PARM_DESC(backup_devices, "MAC addresses of backup devices");
-module_param_named(debug_level, debug_level, uint, S_IRUGO);
-MODULE_PARM_DESC(debug_level, "Debug level");
-
-/** \endcond */
-
-/*****************************************************************************/
-
 /** Module initialization.
  *
  * Initializes \a master_count masters.
  * \return 0 on success, else < 0
  */
-int __init ec_init_module(void)
+int ec_init_module(void)
 {
     int i, ret = 0;
 
@@ -112,7 +90,7 @@
         }
     }
 
-    class = class_create(THIS_MODULE, "EtherCAT");
+    class = class_create("EtherCAT");
     if (IS_ERR(class)) {
         EC_ERR("Failed to create device class.\n");
         ret = PTR_ERR(class);
@@ -139,8 +117,7 @@
     ec_master_init_static();
 
     if (master_count) {
-        if (!(masters = kmalloc(sizeof(ec_master_t) * master_count,
-                        GFP_KERNEL))) {
+        if (!(masters = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_master_t) * master_count))) {
             EC_ERR("Failed to allocate memory"
                     " for EtherCAT masters.\n");
             ret = -ENOMEM;
@@ -162,7 +139,7 @@
 out_free_masters:
     for (i--; i >= 0; i--)
         ec_master_clear(&masters[i]);
-    kfree(masters);
+    PRT_MemFree(OS_MID_SYS, masters);
 out_class:
     class_destroy(class);
 out_cdev:
@@ -178,7 +155,7 @@
  *
  * Clears all master instances.
  */
-void __exit ec_cleanup_module(void)
+void ec_cleanup_module(void)
 {
     unsigned int i;
 
@@ -187,7 +164,7 @@
     }
 
     if (master_count)
-        kfree(masters);
+        PRT_MemFree(OS_MID_SYS, masters);
 
     class_destroy(class);
 
@@ -346,20 +323,20 @@
 
     EC_DBG("");
     for (i = 0; i < size; i++) {
-        printk(KERN_CONT "%02X ", data[i]);
+        printf("%02X ", data[i]);
 
         if ((i + 1) % 16 == 0 && i < size - 1) {
-            printk(KERN_CONT "\n");
+            printf("\n");
             EC_DBG("");
         }
 
         if (i + 1 == 128 && size > 256) {
-            printk(KERN_CONT "dropped %zu bytes\n", size - 128 - i);
+            printf("dropped %zu bytes\n", size - 128 - i);
             i = size - 128;
             EC_DBG("");
         }
     }
-    printk(KERN_CONT "\n");
+    printf("\n");
 }
 
 /*****************************************************************************/
@@ -376,17 +353,17 @@
     EC_DBG("");
     for (i = 0; i < size; i++) {
         if (d1[i] == d2[i]) {
-            printk(KERN_CONT ".. ");
+            printf(".. ");
         }
         else {
-            printk(KERN_CONT "%02X ", d2[i]);
+            printf("%02X ", d2[i]);
         }
         if ((i + 1) % 16 == 0) {
-            printk(KERN_CONT "\n");
+            printf("\n");
             EC_DBG("");
         }
     }
-    printk(KERN_CONT "\n");
+    printf("\n");
 }
 
 /*****************************************************************************/
@@ -504,7 +481,7 @@
 
                 ec_device_attach(&master->devices[dev_idx],
                         net_dev, poll, module);
-                ec_lock_up(&master->device_sem);
+                ec_unlock(&master->device_sem);
 
                 snprintf(net_dev->name, IFNAMSIZ, "ec%c%u",
                         ec_device_names[dev_idx != 0][0], master->index);
@@ -513,7 +490,7 @@
             }
         }
 
-        ec_lock_up(&master->device_sem);
+        ec_unlock(&master->device_sem);
 
         EC_MASTER_DBG(master, 1, "Master declined device %s.\n", str);
     }
@@ -553,13 +530,13 @@
     }
 
     if (master->reserved) {
-        ec_lock_up(&master_sem);
+        ec_unlock(&master_sem);
         EC_MASTER_ERR(master, "Master already in use!\n");
         errptr = ERR_PTR(-EBUSY);
         goto out_return;
     }
     master->reserved = 1;
-    ec_lock_up(&master_sem);
+    ec_unlock(&master_sem);
 
     if (ec_lock_down_interruptible(&master->device_sem)) {
         errptr = ERR_PTR(-EINTR);
@@ -567,7 +544,7 @@
     }
 
     if (master->phase != EC_IDLE) {
-        ec_lock_up(&master->device_sem);
+        ec_unlock(&master->device_sem);
         EC_MASTER_ERR(master, "Master still waiting for devices!\n");
         errptr = ERR_PTR(-ENODEV);
         goto out_release;
@@ -576,14 +553,14 @@
     for (; dev_idx < ec_master_num_devices(master); dev_idx++) {
         ec_device_t *device = &master->devices[dev_idx];
         if (!try_module_get(device->module)) {
-            ec_lock_up(&master->device_sem);
+            ec_unlock(&master->device_sem);
             EC_MASTER_ERR(master, "Device module is unloading!\n");
             errptr = ERR_PTR(-ENODEV);
             goto out_module_put;
         }
     }
 
-    ec_lock_up(&master->device_sem);
+    ec_unlock(&master->device_sem);
 
     if (ec_master_enter_operation_phase(master)) {
         EC_MASTER_ERR(master, "Failed to enter OPERATION phase!\n");
@@ -661,18 +638,3 @@
 };
 
 /*****************************************************************************/
-
-/** \cond */
-
-module_init(ec_init_module);
-module_exit(ec_cleanup_module);
-
-EXPORT_SYMBOL(ecdev_offer);
-
-EXPORT_SYMBOL(ecrt_request_master);
-EXPORT_SYMBOL(ecrt_release_master);
-EXPORT_SYMBOL(ecrt_version_magic);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/pdo.c ethercat-master-m/master/pdo.c
--- ethercat-master/master/pdo.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/pdo.c	2023-08-08 19:51:01.402960100 +0800
@@ -34,9 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-#include <linux/err.h>
-
 #include "pdo.h"
 
 /*****************************************************************************/
@@ -94,7 +91,7 @@
 void ec_pdo_clear(ec_pdo_t *pdo /**< EtherCAT PDO. */)
 {
     if (pdo->name)
-        kfree(pdo->name);
+        PRT_MemFree(OS_MID_SYS, pdo->name);
 
     ec_pdo_clear_entries(pdo);
 }
@@ -108,10 +105,10 @@
     ec_pdo_entry_t *entry, *next;
 
     // free all PDO entries
-    list_for_each_entry_safe(entry, next, &pdo->entries, list) {
+    list_for_each_entry_safe(entry, next, ec_pdo_entry_t, &pdo->entries, list) {
         list_del(&entry->list);
         ec_pdo_entry_clear(entry);
-        kfree(entry);
+        PRT_MemFree(OS_MID_SYS, entry);
     }
 }
 
@@ -133,10 +130,10 @@
         return 0;
 
     if (pdo->name)
-        kfree(pdo->name);
+        PRT_MemFree(OS_MID_SYS, pdo->name);
 
     if (name && (len = strlen(name))) {
-        if (!(pdo->name = (char *) kmalloc(len + 1, GFP_KERNEL))) {
+        if (!(pdo->name = (char *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, len + 1))) {
             EC_ERR("Failed to allocate PDO name.\n");
             return -ENOMEM;
         }
@@ -163,7 +160,7 @@
 {
     ec_pdo_entry_t *entry;
 
-    if (!(entry = kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+    if (!(entry = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_entry_t)))) {
         EC_ERR("Failed to allocate memory for PDO entry.\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -193,16 +190,16 @@
 
     ec_pdo_clear_entries(pdo);
 
-    list_for_each_entry(other_entry, &other->entries, list) {
+    list_for_each_entry(other_entry, ec_pdo_entry_t, &other->entries, list) {
         if (!(entry = (ec_pdo_entry_t *)
-                    kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+                    PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_entry_t)))) {
             EC_ERR("Failed to allocate memory for PDO entry copy.\n");
             return -ENOMEM;
         }
 
         ret = ec_pdo_entry_init_copy(entry, other_entry);
         if (ret < 0) {
-            kfree(entry);
+            PRT_MemFree(OS_MID_SYS, entry);
             return ret;
         }
 
@@ -261,7 +258,7 @@
     const ec_pdo_entry_t *entry;
     unsigned int num = 0;
 
-    list_for_each_entry(entry, &pdo->entries, list) {
+    list_for_each_entry(entry, ec_pdo_entry_t, &pdo->entries, list) {
         num++;
     }
 
@@ -283,7 +280,7 @@
 {
     const ec_pdo_entry_t *entry;
 
-    list_for_each_entry(entry, &pdo->entries, list) {
+    list_for_each_entry(entry, ec_pdo_entry_t, &pdo->entries, list) {
         if (pos--)
             continue;
         return entry;
@@ -303,13 +300,13 @@
     const ec_pdo_entry_t *entry;
 
     if (list_empty(&pdo->entries)) {
-        printk(KERN_CONT "(none)");
+        printf("(none)");
     } else {
-        list_for_each_entry(entry, &pdo->entries, list) {
-            printk(KERN_CONT "0x%04X:%02X/%u",
+        list_for_each_entry(entry, ec_pdo_entry_t, &pdo->entries, list) {
+            printf("0x%04X:%02X/%u",
                     entry->index, entry->subindex, entry->bit_length);
             if (entry->list.next != &pdo->entries)
-                printk(KERN_CONT " ");
+                printf(" ");
         }
     }
 }
diff -urN ethercat-master/master/pdo.h ethercat-master-m/master/pdo.h
--- ethercat-master/master/pdo.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/pdo.h	2023-08-08 19:51:00.848954700 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_PDO_H__
 #define __EC_PDO_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "pdo_entry.h"
 
diff -urN ethercat-master/master/pdo_entry.c ethercat-master-m/master/pdo_entry.c
--- ethercat-master/master/pdo_entry.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/pdo_entry.c	2023-08-08 19:51:01.599273800 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "pdo_entry.h"
 
 /*****************************************************************************/
@@ -76,7 +74,7 @@
 void ec_pdo_entry_clear(ec_pdo_entry_t *entry /**< PDO entry. */)
 {
     if (entry->name)
-        kfree(entry->name);
+        PRT_MemFree(OS_MID_SYS, entry->name);
 }
 
 /*****************************************************************************/
@@ -97,10 +95,10 @@
         return 0;
 
     if (entry->name)
-        kfree(entry->name);
+        PRT_MemFree(OS_MID_SYS, entry->name);
 
     if (name && (len = strlen(name))) {
-        if (!(entry->name = (char *) kmalloc(len + 1, GFP_KERNEL))) {
+        if (!(entry->name = (char *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, len + 1))) {
             EC_ERR("Failed to allocate PDO entry name.\n");
             return -ENOMEM;
         }
diff -urN ethercat-master/master/pdo_entry.h ethercat-master-m/master/pdo_entry.h
--- ethercat-master/master/pdo_entry.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/pdo_entry.h	2023-08-08 19:51:01.482048300 +0800
@@ -37,9 +37,9 @@
 #ifndef __EC_PDO_ENTRY_H__
 #define __EC_PDO_ENTRY_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#include "rtos_list.h"
+#include "prt_mem.h"
 
 /*****************************************************************************/
 
diff -urN ethercat-master/master/pdo_list.c ethercat-master-m/master/pdo_list.c
--- ethercat-master/master/pdo_list.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/pdo_list.c	2023-08-08 19:51:01.066318200 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-
 #include "globals.h"
 #include "pdo.h"
 #include "slave_config.h"
@@ -71,10 +69,10 @@
 {
     ec_pdo_t *pdo, *next;
 
-    list_for_each_entry_safe(pdo, next, &pl->list, list) {
+    list_for_each_entry_safe(pdo, next, ec_pdo_t, &pl->list, list) {
         list_del_init(&pdo->list);
         ec_pdo_clear(pdo);
-        kfree(pdo);
+        PRT_MemFree(OS_MID_SYS, pdo);
     }
 }
 
@@ -94,8 +92,8 @@
     uint16_t byte_size;
 
     bit_size = 0;
-    list_for_each_entry(pdo, &pl->list, list) {
-        list_for_each_entry(pdo_entry, &pdo->entries, list) {
+    list_for_each_entry(pdo, ec_pdo_t, &pl->list, list) {
+        list_for_each_entry(pdo_entry, ec_pdo_entry_t, &pdo->entries, list) {
             bit_size += pdo_entry->bit_length;
         }
     }
@@ -121,7 +119,7 @@
 {
     ec_pdo_t *pdo;
 
-    if (!(pdo = (ec_pdo_t *) kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+    if (!(pdo = (ec_pdo_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_t)))) {
         EC_ERR("Failed to allocate memory for PDO.\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -147,20 +145,20 @@
     int ret;
 
     // PDO already mapped?
-    list_for_each_entry(mapped_pdo, &pl->list, list) {
+    list_for_each_entry(mapped_pdo, ec_pdo_t, &pl->list, list) {
         if (mapped_pdo->index != pdo->index) continue;
         EC_ERR("PDO 0x%04X is already mapped!\n", pdo->index);
         return -EEXIST;
     }
 
-    if (!(mapped_pdo = kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+    if (!(mapped_pdo = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_t)))) {
         EC_ERR("Failed to allocate PDO memory.\n");
         return -ENOMEM;
     }
 
     ret = ec_pdo_init_copy(mapped_pdo, pdo);
     if (ret < 0) {
-        kfree(mapped_pdo);
+        PRT_MemFree(OS_MID_SYS, mapped_pdo);
         return ret;
     }
 
@@ -185,7 +183,7 @@
     ec_pdo_list_clear_pdos(pl);
 
     // PDO already mapped?
-    list_for_each_entry(other_pdo, &other->list, list) {
+    list_for_each_entry(other_pdo, ec_pdo_t, &other->list, list) {
         ret = ec_pdo_list_add_pdo_copy(pl, other_pdo);
         if (ret)
             return ret;
@@ -247,7 +245,7 @@
 {
     ec_pdo_t *pdo;
 
-    list_for_each_entry(pdo, &pl->list, list) {
+    list_for_each_entry(pdo, ec_pdo_t, &pl->list, list) {
         if (pdo->index != index)
             continue;
         return pdo;
@@ -269,7 +267,7 @@
 {
     const ec_pdo_t *pdo;
 
-    list_for_each_entry(pdo, &pl->list, list) {
+    list_for_each_entry(pdo, ec_pdo_t, &pl->list, list) {
         if (pdo->index != index)
             continue;
         return pdo;
@@ -293,7 +291,7 @@
 {
     const ec_pdo_t *pdo;
 
-    list_for_each_entry(pdo, &pl->list, list) {
+    list_for_each_entry(pdo, ec_pdo_t, &pl->list, list) {
         if (pos--)
             continue;
         return pdo;
@@ -315,7 +313,7 @@
     const ec_pdo_t *pdo;
     unsigned int num = 0;
 
-    list_for_each_entry(pdo, &pl->list, list) {
+    list_for_each_entry(pdo, ec_pdo_t, &pl->list, list) {
         num++;
     }
 
@@ -333,12 +331,12 @@
     const ec_pdo_t *pdo;
 
     if (list_empty(&pl->list)) {
-        printk(KERN_CONT "(none)");
+        printf("(none)");
     } else {
-        list_for_each_entry(pdo, &pl->list, list) {
-            printk(KERN_CONT "0x%04X", pdo->index);
+        list_for_each_entry(pdo, ec_pdo_t, &pl->list, list) {
+            printf("0x%04X", pdo->index);
             if (pdo->list.next != &pl->list)
-                printk(KERN_CONT " ");
+                printf(" ");
         }
     }
 }
diff -urN ethercat-master/master/pdo_list.h ethercat-master-m/master/pdo_list.h
--- ethercat-master/master/pdo_list.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/pdo_list.h	2023-08-08 19:51:00.893033500 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_PDO_LIST_H__
 #define __EC_PDO_LIST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "pdo.h"
 
diff -urN ethercat-master/master/reg_request.c ethercat-master-m/master/reg_request.c
--- ethercat-master/master/reg_request.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/reg_request.c	2023-08-08 19:51:01.382905300 +0800
@@ -33,10 +33,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/slab.h>
-
 #include "reg_request.h"
 
 /*****************************************************************************/
@@ -50,7 +46,7 @@
         size_t size /**< Memory size. */
         )
 {
-    if (!(reg->data = (uint8_t *) kmalloc(size, GFP_KERNEL))) {
+    if (!(reg->data = (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
         EC_ERR("Failed to allocate %zu bytes of register memory.\n", size);
         return -ENOMEM;
     }
@@ -75,7 +71,7 @@
         )
 {
     if (reg->data) {
-        kfree(reg->data);
+        PRT_MemFree(OS_MID_SYS, reg->data);
     }
 }
 
@@ -118,14 +114,3 @@
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecrt_reg_request_data);
-EXPORT_SYMBOL(ecrt_reg_request_state);
-EXPORT_SYMBOL(ecrt_reg_request_write);
-EXPORT_SYMBOL(ecrt_reg_request_read);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/reg_request.h ethercat-master-m/master/reg_request.h
--- ethercat-master/master/reg_request.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/reg_request.h	2023-08-08 19:51:01.166477400 +0800
@@ -37,9 +37,9 @@
 #ifndef __EC_REG_REQUEST_H__
 #define __EC_REG_REQUEST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#include "rtos_list.h"
+#include "prt_mem.h"
 
 /*****************************************************************************/
 
diff -urN ethercat-master/master/rtdm-ioctl.c ethercat-master-m/master/rtdm-ioctl.c
--- ethercat-master/master/rtdm-ioctl.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/rtdm-ioctl.c	2023-08-08 19:51:01.025228900 +0800
@@ -1428,7 +1428,7 @@
     ioctl->subindex = req->subindex;
     ioctl->size = req->data_size;
     memcpy(ioctl->data, req->data,
-            min((u32) ioctl->size, (u32) EC_MAX_SDO_DATA_SIZE));
+            min((U32) ioctl->size, (U32) EC_MAX_SDO_DATA_SIZE));
     ioctl->complete_access = req->complete_access;
 
     ec_lock_up(&master->master_sem);
@@ -1493,7 +1493,7 @@
     ioctl->state = req->state;
     ioctl->size = req->data_size;
     memcpy(ioctl->data, req->data,
-            min((u32) ioctl->size, (u32) EC_MAX_IDN_DATA_SIZE));
+            min((U32) ioctl->size, (U32) EC_MAX_IDN_DATA_SIZE));
 
     ec_lock_up(&master->master_sem);
 
@@ -1553,7 +1553,7 @@
         return -EINVAL;
     }
 
-    size = min((u32) strlen(flag->key), (u32) EC_MAX_FLAG_KEY_SIZE - 1);
+    size = min((U32) strlen(flag->key), (U32) EC_MAX_FLAG_KEY_SIZE - 1);
     memcpy(ioctl->key, flag->key, size);
     ioctl->key[size] = 0x00;
     ioctl->value = flag->value;
@@ -3017,7 +3017,7 @@
 {
     ec_ioctl_sc_emerg_t io;
     ec_slave_config_t *sc;
-    u8 msg[EC_COE_EMERGENCY_MSG_SIZE];
+    U8 msg[EC_COE_EMERGENCY_MSG_SIZE];
     int ret;
 
     if (unlikely(!ctx->requested)) {
@@ -4537,7 +4537,7 @@
         )
 {
     ec_ioctl_slave_soe_read_t ioctl;
-    u8 *data;
+    U8 *data;
     int retval;
 
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
@@ -4586,7 +4586,7 @@
         )
 {
     ec_ioctl_slave_soe_write_t ioctl;
-    u8 *data;
+    U8 *data;
     int retval;
 
     if (copy_from_user(&ioctl, (void __user *) arg, sizeof(ioctl))) {
diff -urN ethercat-master/master/rtdm.c ethercat-master-m/master/rtdm.c
--- ethercat-master/master/rtdm.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/rtdm.c	2023-08-08 19:51:00.754770900 +0800
@@ -30,10 +30,6 @@
  * RTDM interface.
  */
 
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/mman.h>
-
 #include <rtdm/rtdm_driver.h>
 
 #include "master.h"
@@ -105,7 +101,7 @@
     if (ret) {
         EC_MASTER_ERR(master, "Initialization of RTDM interface failed"
                 " (return value %i).\n", ret);
-        kfree(rtdm_dev->dev);
+        PRT_MemFree(OS_MID_SYS, rtdm_dev->dev);
     }
 
     return ret;
@@ -129,7 +125,7 @@
                 "Failed to unregister RTDM device (code %i).\n", ret);
     }
 
-    kfree(rtdm_dev->dev);
+    PRT_MemFree(OS_MID_SYS, rtdm_dev->dev);
 }
 
 /****************************************************************************/
diff -urN ethercat-master/master/rtos_list.h ethercat-master-m/master/rtos_list.h
--- ethercat-master/master/rtos_list.h	1970-01-01 08:00:00.000000000 +0800
+++ ethercat-master-m/master/rtos_list.h	2023-08-08 19:51:01.655797000 +0800
@@ -0,0 +1,114 @@
+/*
+ * 双向链表操作的内部头文件
+ */
+#ifndef RTOS_LIST_H
+#define RTOS_LIST_H
+
+#include "prt_typedef.h"
+
+struct list_head {
+    struct list_head *prev;
+    struct list_head *next;
+};
+
+struct wait_queue_head {
+    volatile unsigned int lock;
+    struct list_head      head;
+};
+
+typedef struct wait_queue_head wait_queue_head_t;
+
+#define INIT_LIST_HEAD(head)   \
+    do {                       \
+        (head)->prev = (head); \
+        (head)->next = (head); \
+    } while (0)
+
+#define INIT_LIST_OBJECT(object)   \
+    do {                           \
+        (object)->next = (object); \
+        (object)->prev = (object); \
+    } while (0)
+
+static inline void list_low_level_add(struct list_head *newNode, struct list_head *prev,
+                                      struct list_head *next)
+{
+    newNode->next = next;
+    newNode->prev = prev;
+    next->prev = newNode;
+    prev->next = newNode;
+}
+
+static inline int list_empty(const struct list_head *head)
+{
+    return head->next == head;
+}
+
+static inline void list_add(struct list_head *newNode, struct list_head *listObject)
+{
+    list_low_level_add(newNode, listObject, listObject->next);
+}
+
+static inline void list_add_tail(struct list_head *newNode, struct list_head *listObject)
+{
+    list_low_level_add(newNode, listObject->prev, listObject);
+}
+
+static inline void list_low_level_del(struct list_head *prevNode, struct list_head *nextNode)
+{
+    nextNode->prev = prevNode;
+    prevNode->next = nextNode;
+}
+
+static inline list_del(struct list_head *node)
+{
+    list_low_level_del(node->prev, node->next);
+
+    node->next = NULL;
+    node->prev = NULL;
+}
+
+static inline void list_del_init(struct list_head *node)
+{
+    list_low_level_del(node->prev, node->next);
+    INIT_LIST_OBJECT(node);
+}
+
+static inline int list_is_head(const struct list_head *list, const struct list_head *head)
+{
+    return list == head;
+}
+
+#define list_entry_is_head(pos, head, member)  \
+    (&pos->member == (head))
+
+#define offsetof(type, member) ((uintptr_t) &((type *)0)->member)
+
+#define container_of(ptr, type, member) ((type *)((uintptr_t)(ptr) - offsetof(type, member)))
+
+#define list_for_each_safe(pos, n, head)     \
+    for (pos = (head)->next, n = pos->next); \
+         !list_is_head(pos, (head));         \
+         pos = n, n = pos->next)
+
+#define list_entry(ptr, type, member)  \
+    container_of(ptr, type, member)
+
+#define list_first_entry(ptr, type, member)  \
+    list_entry((ptr)->next, type, member)
+
+#define list_next_entry(pos, type, member)   \
+    list_entry((pos)->member.next, type, member)
+
+#define list_for_each_entry(pos, type, head, member)  \
+    for (pos = list_first_entry(head, type, member);  \
+         !list_entry_is_head(pos, head, member);      \
+         pos = list_next_entry(pos, type, member))
+
+#define list_for_each_entry_safe(pos, n, type, head, member)  \
+    for (pos = list_first_entry(head, type, member),          \
+         n = list_next_entry(pos, type, member);              \
+         !list_entry_is_head(pos, head, member);              \
+         pos = n, n = list_next_entry(n, type, member))
+
+#endif /* RTOS_LIST_H */
\ No newline at end of file
diff -urN ethercat-master/master/sdo.c ethercat-master-m/master/sdo.c
--- ethercat-master/master/sdo.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/sdo.c	2023-08-08 19:51:00.664576100 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "master.h"
 
 #include "sdo.h"
@@ -71,14 +69,14 @@
     ec_sdo_entry_t *entry, *next;
 
     // free all entries
-    list_for_each_entry_safe(entry, next, &sdo->entries, list) {
+    list_for_each_entry_safe(entry, next, ec_sdo_entry_t, &sdo->entries, list) {
         list_del(&entry->list);
         ec_sdo_entry_clear(entry);
-        kfree(entry);
+        PRT_MemFree(OS_MID_SYS, entry);
     }
 
     if (sdo->name)
-        kfree(sdo->name);
+        PRT_MemFree(OS_MID_SYS, sdo->name);
 }
 
 /*****************************************************************************/
@@ -95,7 +93,7 @@
 {
     ec_sdo_entry_t *entry;
 
-    list_for_each_entry(entry, &sdo->entries, list) {
+    list_for_each_entry(entry, ec_sdo_entry_t, &sdo->entries, list) {
         if (entry->subindex != subindex)
             continue;
         return entry;
@@ -120,7 +118,7 @@
 {
     const ec_sdo_entry_t *entry;
 
-    list_for_each_entry(entry, &sdo->entries, list) {
+    list_for_each_entry(entry, ec_sdo_entry_t, &sdo->entries, list) {
         if (entry->subindex != subindex)
             continue;
         return entry;
diff -urN ethercat-master/master/sdo.h ethercat-master-m/master/sdo.h
--- ethercat-master/master/sdo.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/sdo.h	2023-08-08 19:51:00.980153900 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_SDO_H__
 #define __EC_SDO_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "sdo_entry.h"
 
diff -urN ethercat-master/master/sdo_entry.c ethercat-master-m/master/sdo_entry.c
--- ethercat-master/master/sdo_entry.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/sdo_entry.c	2023-08-08 19:51:01.559161200 +0800
@@ -34,8 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/slab.h>
-
 #include "sdo_entry.h"
 
 /*****************************************************************************/
@@ -71,7 +69,7 @@
 {
 
     if (entry->description)
-        kfree(entry->description);
+        PRT_MemFree(OS_MID_SYS, entry->description);
 }
 
 /*****************************************************************************/
diff -urN ethercat-master/master/sdo_entry.h ethercat-master-m/master/sdo_entry.h
--- ethercat-master/master/sdo_entry.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/sdo_entry.h	2023-08-08 19:51:01.462008500 +0800
@@ -37,10 +37,9 @@
 #ifndef __EC_SDO_ENTRY_H__
 #define __EC_SDO_ENTRY_H__
 
-#include <linux/list.h>
-#include <linux/kobject.h>
-
 #include "globals.h"
+#include "rtos_list.h"
+#include "prt_mem.h"
 
 /*****************************************************************************/
 
diff -urN ethercat-master/master/sdo_request.c ethercat-master-m/master/sdo_request.c
--- ethercat-master/master/sdo_request.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/sdo_request.c	2023-08-08 19:51:01.251631600 +0800
@@ -33,10 +33,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/slab.h>
-
 #include "sdo_request.h"
 
 /*****************************************************************************/
@@ -65,7 +61,7 @@
     req->issue_timeout = 0; // no timeout
     req->response_timeout = EC_SDO_REQUEST_RESPONSE_TIMEOUT;
     req->state = EC_INT_REQUEST_INIT;
-    req->errno = 0;
+    req->err_no = 0;
     req->abort_code = 0x00000000;
 }
 
@@ -108,7 +104,7 @@
         )
 {
     if (req->data) {
-        kfree(req->data);
+        PRT_MemFree(OS_MID_SYS, req->data);
         req->data = NULL;
     }
 
@@ -134,7 +130,7 @@
 
     ec_sdo_request_clear_data(req);
 
-    if (!(req->data = (uint8_t *) kmalloc(size, GFP_KERNEL))) {
+    if (!(req->data = (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
         EC_ERR("Failed to allocate %zu bytes of SDO memory.\n", size);
         return -ENOMEM;
     }
@@ -177,7 +173,7 @@
 int ec_sdo_request_timed_out(const ec_sdo_request_t *req /**< SDO request. */)
 {
     return req->issue_timeout
-        && jiffies - req->jiffies_start > HZ * req->issue_timeout / 1000;
+        && get_jiffies() - req->jiffies_start > HZ * req->issue_timeout / 1000;
 }
 
 /*****************************************************************************
@@ -225,9 +221,9 @@
 {
     req->dir = EC_DIR_INPUT;
     req->state = EC_INT_REQUEST_QUEUED;
-    req->errno = 0;
+    req->err_no = 0;
     req->abort_code = 0x00000000;
-    req->jiffies_start = jiffies;
+    req->jiffies_start = get_jiffies();
 }
 
 /*****************************************************************************/
@@ -236,23 +232,9 @@
 {
     req->dir = EC_DIR_OUTPUT;
     req->state = EC_INT_REQUEST_QUEUED;
-    req->errno = 0;
+    req->err_no = 0;
     req->abort_code = 0x00000000;
-    req->jiffies_start = jiffies;
+    req->jiffies_start = get_jiffies();
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecrt_sdo_request_index);
-EXPORT_SYMBOL(ecrt_sdo_request_timeout);
-EXPORT_SYMBOL(ecrt_sdo_request_data);
-EXPORT_SYMBOL(ecrt_sdo_request_data_size);
-EXPORT_SYMBOL(ecrt_sdo_request_state);
-EXPORT_SYMBOL(ecrt_sdo_request_read);
-EXPORT_SYMBOL(ecrt_sdo_request_write);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/sdo_request.h ethercat-master-m/master/sdo_request.h
--- ethercat-master/master/sdo_request.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/sdo_request.h	2023-08-08 19:51:01.363845000 +0800
@@ -37,9 +37,9 @@
 #ifndef __EC_SDO_REQUEST_H__
 #define __EC_SDO_REQUEST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
+#include "rtos_list.h"
+#include "prt_mem.h"
 
 /*****************************************************************************/
 
@@ -64,7 +64,7 @@
     unsigned long jiffies_start; /**< Jiffies, when the request was issued. */
     unsigned long jiffies_sent; /**< Jiffies, when the upload/download
                                      request was sent. */
-    int errno; /**< Error number. */
+    int err_no; /**< Error number. */
     uint32_t abort_code; /**< SDO request abort code. Zero on success. */
 };
 
diff -urN ethercat-master/master/slave.c ethercat-master-m/master/slave.c
--- ethercat-master/master/slave.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/slave.c	2023-08-08 19:51:01.618293800 +0800
@@ -34,9 +34,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/delay.h>
-
 #include "globals.h"
 #include "datagram.h"
 #include "master.h"
@@ -278,31 +275,31 @@
     }
 
     // free all SDOs
-    list_for_each_entry_safe(sdo, next_sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry_safe(sdo, next_sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         list_del(&sdo->list);
         ec_sdo_clear(sdo);
-        kfree(sdo);
+        PRT_MemFree(OS_MID_SYS, sdo);
     }
 
     // free all strings
     if (slave->sii.strings) {
         for (i = 0; i < slave->sii.string_count; i++)
-            kfree(slave->sii.strings[i]);
-        kfree(slave->sii.strings);
+            PRT_MemFree(OS_MID_SYS, slave->sii.strings[i]);
+        PRT_MemFree(OS_MID_SYS, slave->sii.strings);
     }
 
     // free all sync managers
     ec_slave_clear_sync_managers(slave);
 
     // free all SII PDOs
-    list_for_each_entry_safe(pdo, next_pdo, &slave->sii.pdos, list) {
+    list_for_each_entry_safe(pdo, next_pdo, ec_pdo_t, &slave->sii.pdos, list) {
         list_del(&pdo->list);
         ec_pdo_clear(pdo);
-        kfree(pdo);
+        PRT_MemFree(OS_MID_SYS, pdo);
     }
 
     if (slave->sii_words) {
-        kfree(slave->sii_words);
+        PRT_MemFree(OS_MID_SYS, slave->sii_words);
     }
 
     // free mailbox response data
@@ -330,7 +327,7 @@
         for (i = 0; i < slave->sii.sync_count; i++) {
             ec_sync_clear(&slave->sii.syncs[i]);
         }
-        kfree(slave->sii.syncs);
+        PRT_MemFree(OS_MID_SYS, slave->sii.syncs);
         slave->sii.syncs = NULL;
     }
 }
@@ -433,8 +430,7 @@
 
     if (slave->sii.string_count) {
         if (!(slave->sii.strings =
-                    kmalloc(sizeof(char *) * slave->sii.string_count,
-                        GFP_KERNEL))) {
+                    PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(char *) * slave->sii.string_count))) {
             EC_SLAVE_ERR(slave, "Failed to allocate string array memory.\n");
             err = -ENOMEM;
             goto out_zero;
@@ -445,7 +441,7 @@
             size = data[offset];
             // allocate memory for string structure and data at a single blow
             if (!(slave->sii.strings[i] =
-                        kmalloc(sizeof(char) * size + 1, GFP_KERNEL))) {
+                        PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(char) * size + 1))) {
                 EC_SLAVE_ERR(slave, "Failed to allocate string memory.\n");
                 err = -ENOMEM;
                 goto out_free;
@@ -460,8 +456,8 @@
 
 out_free:
     for (i--; i >= 0; i--)
-        kfree(slave->sii.strings[i]);
-    kfree(slave->sii.strings);
+        PRT_MemFree(OS_MID_SYS, slave->sii.strings[i]);
+    PRT_MemFree(OS_MID_SYS, slave->sii.strings);
     slave->sii.strings = NULL;
 out_zero:
     slave->sii.string_count = 0;
@@ -555,7 +551,7 @@
             return -EOVERFLOW;
         }
         memsize = sizeof(ec_sync_t) * total_count;
-        if (!(syncs = kmalloc(memsize, GFP_KERNEL))) {
+        if (!(syncs = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, memsize))) {
             EC_SLAVE_ERR(slave, "Failed to allocate %zu bytes"
                     " for sync managers.\n", memsize);
             return -ENOMEM;
@@ -577,7 +573,7 @@
         }
 
         if (slave->sii.syncs)
-            kfree(slave->sii.syncs);
+            PRT_MemFree(OS_MID_SYS, slave->sii.syncs);
         slave->sii.syncs = syncs;
         slave->sii.sync_count = total_count;
     }
@@ -605,7 +601,7 @@
     unsigned int entry_count, i;
 
     while (data_size >= 8) {
-        if (!(pdo = kmalloc(sizeof(ec_pdo_t), GFP_KERNEL))) {
+        if (!(pdo = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_t)))) {
             EC_SLAVE_ERR(slave, "Failed to allocate PDO memory.\n");
             return -ENOMEM;
         }
@@ -618,7 +614,7 @@
                 ec_slave_sii_string(slave, EC_READ_U8(data + 5)));
         if (ret) {
             ec_pdo_clear(pdo);
-            kfree(pdo);
+            PRT_MemFree(OS_MID_SYS, pdo);
             return ret;
         }
         list_add_tail(&pdo->list, &slave->sii.pdos);
@@ -627,7 +623,7 @@
         data += 8;
 
         for (i = 0; i < entry_count; i++) {
-            if (!(entry = kmalloc(sizeof(ec_pdo_entry_t), GFP_KERNEL))) {
+            if (!(entry = PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_pdo_entry_t)))) {
                 EC_SLAVE_ERR(slave, "Failed to allocate PDO entry memory.\n");
                 return -ENOMEM;
             }
@@ -639,7 +635,7 @@
                     ec_slave_sii_string(slave, EC_READ_U8(data + 3)));
             if (ret) {
                 ec_pdo_entry_clear(entry);
-                kfree(entry);
+                PRT_MemFree(OS_MID_SYS, entry);
                 return ret;
             }
             entry->bit_length = EC_READ_U8(data + 5);
@@ -725,9 +721,9 @@
     ec_sdo_t *sdo;
     ec_sdo_entry_t *entry;
 
-    list_for_each_entry(sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry(sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         sdos++;
-        list_for_each_entry(entry, &sdo->entries, list) {
+        list_for_each_entry(entry, ec_sdo_entry_t, &sdo->entries, list) {
             entries++;
         }
     }
@@ -750,7 +746,7 @@
 {
     ec_sdo_t *sdo;
 
-    list_for_each_entry(sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry(sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         if (sdo->index != index)
             continue;
         return sdo;
@@ -776,7 +772,7 @@
 {
     const ec_sdo_t *sdo;
 
-    list_for_each_entry(sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry(sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         if (sdo->index != index)
             continue;
         return sdo;
@@ -798,7 +794,7 @@
 {
     const ec_sdo_t *sdo;
 
-    list_for_each_entry(sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry(sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         if (sdo_position--)
             continue;
         return sdo;
@@ -820,7 +816,7 @@
     const ec_sdo_t *sdo;
     uint16_t count = 0;
 
-    list_for_each_entry(sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry(sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         count++;
     }
 
@@ -866,11 +862,11 @@
     ec_pdo_entry_t *pdo_entry;
     const ec_sdo_entry_t *sdo_entry;
 
-    list_for_each_entry(sdo, &slave->sdo_dictionary, list) {
+    list_for_each_entry(sdo, ec_sdo_t, &slave->sdo_dictionary, list) {
         if (sdo->index == pdo->index) {
             ec_pdo_set_name(pdo, sdo->name);
         } else {
-            list_for_each_entry(pdo_entry, &pdo->entries, list) {
+            list_for_each_entry(pdo_entry, ec_pdo_entry_t, &pdo->entries, list) {
                 if (sdo->index == pdo_entry->index) {
                     sdo_entry = ec_sdo_get_entry_const(
                             sdo, pdo_entry->subindex);
@@ -898,7 +894,7 @@
 
     for (i = 0; i < slave->sii.sync_count; i++) {
         sync = slave->sii.syncs + i;
-        list_for_each_entry(pdo, &sync->pdos.list, list) {
+        list_for_each_entry(pdo, ec_pdo_t, &sync->pdos.list, list) {
             ec_slave_find_names_for_pdo(slave, pdo);
         }
     }
diff -urN ethercat-master/master/slave.h ethercat-master-m/master/slave.h
--- ethercat-master/master/slave.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/slave.h	2023-08-08 19:51:00.694653900 +0800
@@ -37,16 +37,13 @@
 #ifndef __EC_SLAVE_H__
 #define __EC_SLAVE_H__
 
-#include <linux/list.h>
-#include <linux/kobject.h>
-#include <linux/rtmutex.h>
-
 #include "globals.h"
 #include "datagram.h"
 #include "pdo.h"
 #include "sync.h"
 #include "sdo.h"
 #include "fsm_slave.h"
+#include "locks.h"
 
 /*****************************************************************************/
 
@@ -61,7 +58,7 @@
  * \param args arguments (optional)
  */
 #define EC_SLAVE_INFO(slave, fmt, args...) \
-    printk(KERN_INFO "EtherCAT %u-%u: " fmt, slave->master->index, \
+    printf("EtherCAT %u-%u: " fmt, slave->master->index, \
             slave->ring_position, ##args)
 
 /** Convenience macro for printing slave-specific errors to syslog.
@@ -75,7 +72,7 @@
  * \param args arguments (optional)
  */
 #define EC_SLAVE_ERR(slave, fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR %u-%u: " fmt, slave->master->index, \
+    printf("EtherCAT ERROR %u-%u: " fmt, slave->master->index, \
             slave->ring_position, ##args)
 
 /** Convenience macro for printing slave-specific warnings to syslog.
@@ -89,7 +86,7 @@
  * \param args arguments (optional)
  */
 #define EC_SLAVE_WARN(slave, fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING %u-%u: " fmt, \
+    printf("EtherCAT WARNING %u-%u: " fmt, \
             slave->master->index, slave->ring_position, ##args)
 
 /** Convenience macro for printing slave-specific debug messages to syslog.
@@ -107,7 +104,7 @@
 #define EC_SLAVE_DBG(slave, level, fmt, args...) \
     do { \
         if (slave->master->debug_level >= level) { \
-            printk(KERN_DEBUG "EtherCAT DEBUG %u-%u: " fmt, \
+            printf("EtherCAT DEBUG %u-%u: " fmt, \
                     slave->master->index, slave->ring_position, ##args); \
         } \
     } while (0)
@@ -258,7 +255,7 @@
     ec_fsm_slave_t fsm; /**< Slave state machine. */
 
     uint8_t read_mbox_busy; /**< Flag set during a mailbox read request. */
-    struct rt_mutex mbox_sem; /**< Semaphore protecting the check_mbox variable. */
+    ec_lock_t mbox_sem; /**< Semaphore protecting the check_mbox variable. */
 
 #ifdef EC_EOE
     ec_mbox_data_t mbox_eoe_frag_data; /**< Received mailbox data for EoE, type frame fragment. */
diff -urN ethercat-master/master/slave_config.c ethercat-master-m/master/slave_config.c
--- ethercat-master/master/slave_config.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/slave_config.c	2023-08-08 19:51:00.807888800 +0800
@@ -36,9 +36,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/slab.h>
-
 #include "globals.h"
 #include "master.h"
 #include "voe_handler.h"
@@ -120,45 +117,45 @@
         ec_sync_config_clear(&sc->sync_configs[i]);
 
     // free all SDO configurations
-    list_for_each_entry_safe(req, next_req, &sc->sdo_configs, list) {
+    list_for_each_entry_safe(req, next_req, ec_sdo_request_t, &sc->sdo_configs, list) {
         list_del(&req->list);
         ec_sdo_request_clear(req);
-        kfree(req);
+        PRT_MemFree(OS_MID_SYS, req);
     }
 
     // free all SDO requests
-    list_for_each_entry_safe(req, next_req, &sc->sdo_requests, list) {
+    list_for_each_entry_safe(req, next_req, ec_sdo_request_t, &sc->sdo_requests, list) {
         list_del(&req->list);
         ec_sdo_request_clear(req);
-        kfree(req);
+        PRT_MemFree(OS_MID_SYS, req);
     }
 
     // free all register requests
-    list_for_each_entry_safe(reg, next_reg, &sc->reg_requests, list) {
+    list_for_each_entry_safe(reg, next_reg, ec_reg_request_t, &sc->reg_requests, list) {
         list_del(&reg->list);
         ec_reg_request_clear(reg);
-        kfree(reg);
+        PRT_MemFree(OS_MID_SYS, reg);
     }
 
     // free all VoE handlers
-    list_for_each_entry_safe(voe, next_voe, &sc->voe_handlers, list) {
+    list_for_each_entry_safe(voe, next_voe, ec_voe_handler_t, &sc->voe_handlers, list) {
         list_del(&voe->list);
         ec_voe_handler_clear(voe);
-        kfree(voe);
+        PRT_MemFree(OS_MID_SYS, voe);
     }
 
     // free all SoE configurations
-    list_for_each_entry_safe(soe, next_soe, &sc->soe_configs, list) {
+    list_for_each_entry_safe(soe, next_soe, ec_soe_request_t, &sc->soe_configs, list) {
         list_del(&soe->list);
         ec_soe_request_clear(soe);
-        kfree(soe);
+        PRT_MemFree(OS_MID_SYS, soe);
     }
 
     // free all flags
-    list_for_each_entry_safe(flag, next_flag, &sc->flags, list) {
+    list_for_each_entry_safe(flag, next_flag, ec_flag_t, &sc->flags, list) {
         list_del(&flag->list);
         ec_flag_clear(flag);
-        kfree(flag);
+        PRT_MemFree(OS_MID_SYS, flag);
     }
 
     ec_coe_emerg_ring_clear(&sc->emerg_ring);
@@ -202,7 +199,7 @@
 
     fmmu = &sc->fmmu_configs[sc->used_fmmus];
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     ec_fmmu_config_init(fmmu, sc, domain, sync_index, dir);
 
 #if 0 //TODO overlapping PDOs
@@ -235,7 +232,7 @@
 #endif
 
     sc->used_fmmus++;
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
 
     return fmmu->logical_domain_offset;
 }
@@ -315,7 +312,7 @@
         sc->slave->config = NULL;
 
         // invalidate processing register request
-        list_for_each_entry(reg, &sc->reg_requests, list) {
+        list_for_each_entry(reg, ec_reg_request_t, &sc->reg_requests, list) {
             if (sc->slave->fsm.reg_request == reg) {
                 sc->slave->fsm.reg_request = NULL;
                 EC_SLAVE_WARN(sc->slave, "Aborting register request,"
@@ -378,7 +375,7 @@
     for (i = 0; i < sc->slave->sii.sync_count; i++) {
         sync = &sc->slave->sii.syncs[i];
 
-        list_for_each_entry(default_pdo, &sync->pdos.list, list) {
+        list_for_each_entry(default_pdo, ec_pdo_t, &sync->pdos.list, list) {
             if (default_pdo->index != pdo->index)
                 continue;
 
@@ -396,7 +393,7 @@
 
             if (sc->master->debug_level) {
                 const ec_pdo_entry_t *entry;
-                list_for_each_entry(entry, &pdo->entries, list) {
+                list_for_each_entry(entry, ec_pdo_entry_t, &pdo->entries, list) {
                     EC_CONFIG_DBG(sc, 1, "Entry 0x%04X:%02X.\n",
                             entry->index, entry->subindex);
                 }
@@ -422,7 +419,7 @@
     const ec_sdo_request_t *req;
     unsigned int count = 0;
 
-    list_for_each_entry(req, &sc->sdo_configs, list) {
+    list_for_each_entry(req, ec_sdo_request_t, &sc->sdo_configs, list) {
         count++;
     }
 
@@ -444,7 +441,7 @@
 {
     const ec_sdo_request_t *req;
 
-    list_for_each_entry(req, &sc->sdo_configs, list) {
+    list_for_each_entry(req, ec_sdo_request_t, &sc->sdo_configs, list) {
         if (pos--)
             continue;
         return req;
@@ -466,7 +463,7 @@
     const ec_soe_request_t *req;
     unsigned int count = 0;
 
-    list_for_each_entry(req, &sc->soe_configs, list) {
+    list_for_each_entry(req, ec_soe_request_t, &sc->soe_configs, list) {
         count++;
     }
 
@@ -488,7 +485,7 @@
 {
     const ec_soe_request_t *req;
 
-    list_for_each_entry(req, &sc->soe_configs, list) {
+    list_for_each_entry(req, ec_soe_request_t, &sc->soe_configs, list) {
         if (pos--)
             continue;
         return req;
@@ -510,7 +507,7 @@
     const ec_flag_t *flag;
     unsigned int count = 0;
 
-    list_for_each_entry(flag, &sc->flags, list) {
+    list_for_each_entry(flag, ec_flag_t, &sc->flags, list) {
         count++;
     }
 
@@ -532,7 +529,7 @@
 {
     const ec_flag_t *flag;
 
-    list_for_each_entry(flag, &sc->flags, list) {
+    list_for_each_entry(flag, ec_flag_t, &sc->flags, list) {
         if (pos--)
             continue;
         return flag;
@@ -554,7 +551,7 @@
 {
     ec_sdo_request_t *req;
 
-    list_for_each_entry(req, &sc->sdo_requests, list) {
+    list_for_each_entry(req, ec_sdo_request_t, &sc->sdo_requests, list) {
         if (pos--)
             continue;
         return req;
@@ -576,7 +573,7 @@
 {
     ec_reg_request_t *reg;
 
-    list_for_each_entry(reg, &sc->reg_requests, list) {
+    list_for_each_entry(reg, ec_reg_request_t, &sc->reg_requests, list) {
         if (pos--)
             continue;
         return reg;
@@ -598,7 +595,7 @@
 {
     ec_voe_handler_t *voe;
 
-    list_for_each_entry(voe, &sc->voe_handlers, list) {
+    list_for_each_entry(voe, ec_voe_handler_t, &sc->voe_handlers, list) {
         if (pos--)
             continue;
         return voe;
@@ -622,7 +619,7 @@
         return;
     }
 
-    list_for_each_entry(sdo_req, &sc->sdo_requests, list) {
+    list_for_each_entry(sdo_req, ec_sdo_request_t, &sc->sdo_requests, list) {
         if (sdo_req->state == EC_INT_REQUEST_QUEUED ||
                 sdo_req->state == EC_INT_REQUEST_BUSY) {
             EC_CONFIG_DBG(sc, 1,
@@ -631,7 +628,7 @@
         }
     }
 
-    list_for_each_entry(reg_req, &sc->reg_requests, list) {
+    list_for_each_entry(reg_req, ec_reg_request_t, &sc->reg_requests, list) {
         if (reg_req->state == EC_INT_REQUEST_QUEUED ||
                 reg_req->state == EC_INT_REQUEST_BUSY) {
             EC_CONFIG_DBG(sc, 1,
@@ -654,7 +651,7 @@
 {
     if (sc) {
         ec_flag_t *flag;
-        list_for_each_entry(flag, &sc->flags, list) {
+        list_for_each_entry(flag, ec_flag_t, &sc->flags, list) {
             if (!strcmp(flag->key, key)) {
                 return flag;
             }
@@ -731,18 +728,18 @@
         return -EINVAL;
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
 
     pdo = ec_pdo_list_add_pdo(&sc->sync_configs[sync_index].pdos, pdo_index);
     if (IS_ERR(pdo)) {
-        ec_lock_up(&sc->master->master_sem);
+        ec_unlock(&sc->master->master_sem);
         return PTR_ERR(pdo);
     }
     pdo->sync_index = sync_index;
 
     ec_slave_config_load_default_mapping(sc, pdo);
 
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
     return 0;
 }
 
@@ -759,9 +756,9 @@
         return;
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     ec_pdo_list_clear_pdos(&sc->sync_configs[sync_index].pdos);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
 }
 
 /*****************************************************************************/
@@ -787,10 +784,10 @@
             break;
 
     if (pdo) {
-        ec_lock_down(&sc->master->master_sem);
+        ec_lock(&sc->master->master_sem);
         entry = ec_pdo_add_entry(pdo, entry_index, entry_subindex,
                 entry_bit_length);
-        ec_lock_up(&sc->master->master_sem);
+        ec_unlock(&sc->master->master_sem);
         if (IS_ERR(entry))
             retval = PTR_ERR(entry);
     } else {
@@ -818,9 +815,9 @@
             break;
 
     if (pdo) {
-        ec_lock_down(&sc->master->master_sem);
+        ec_lock(&sc->master->master_sem);
         ec_pdo_clear_entries(pdo);
-        ec_lock_up(&sc->master->master_sem);
+        ec_unlock(&sc->master->master_sem);
     } else {
         EC_CONFIG_WARN(sc, "PDO 0x%04X is not assigned.\n", pdo_index);
     }
@@ -918,8 +915,8 @@
         sync_config = &sc->sync_configs[sync_index];
         bit_offset = 0;
 
-        list_for_each_entry(pdo, &sync_config->pdos.list, list) {
-            list_for_each_entry(entry, &pdo->entries, list) {
+        list_for_each_entry(pdo, ec_pdo_t, &sync_config->pdos.list, list) {
+            list_for_each_entry(entry, ec_pdo_entry_t, &pdo->entries, list) {
                 if (entry->index != index || entry->subindex != subindex) {
                     bit_offset += entry->bit_length;
                 } else {
@@ -978,9 +975,9 @@
     bit_offset = 0;
     pp = 0;
 
-    list_for_each_entry(pdo, &sync_config->pdos.list, list) {
+    list_for_each_entry(pdo, ec_pdo_t, &sync_config->pdos.list, list) {
         ep = 0;
-        list_for_each_entry(entry, &pdo->entries, list) {
+        list_for_each_entry(entry, ec_pdo_entry_t, &pdo->entries, list) {
             if (pp != pdo_pos || ep != entry_pos) {
                 bit_offset += entry->bit_length;
             } else {
@@ -1050,7 +1047,7 @@
     }
 
     if (!(req = (ec_sdo_request_t *)
-          kmalloc(sizeof(ec_sdo_request_t), GFP_KERNEL))) {
+          PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_sdo_request_t)))) {
         EC_CONFIG_ERR(sc, "Failed to allocate memory for"
                 " SDO configuration!\n");
         return -ENOMEM;
@@ -1062,13 +1059,13 @@
     ret = ec_sdo_request_copy_data(req, data, size);
     if (ret < 0) {
         ec_sdo_request_clear(req);
-        kfree(req);
+        PRT_MemFree(OS_MID_SYS, req);
         return ret;
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_configs);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
     return 0;
 }
 
@@ -1134,7 +1131,7 @@
     }
 
     if (!(req = (ec_sdo_request_t *)
-          kmalloc(sizeof(ec_sdo_request_t), GFP_KERNEL))) {
+          PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_sdo_request_t)))) {
         EC_CONFIG_ERR(sc, "Failed to allocate memory for"
                 " SDO configuration!\n");
         return -ENOMEM;
@@ -1147,13 +1144,13 @@
     ret = ec_sdo_request_copy_data(req, data, size);
     if (ret < 0) {
         ec_sdo_request_clear(req);
-        kfree(req);
+        PRT_MemFree(OS_MID_SYS, req);
         return ret;
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_configs);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
     return 0;
 }
 
@@ -1201,7 +1198,7 @@
             __func__, sc, index, subindex, size);
 
     if (!(req = (ec_sdo_request_t *)
-                kmalloc(sizeof(ec_sdo_request_t), GFP_KERNEL))) {
+                PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_sdo_request_t)))) {
         EC_CONFIG_ERR(sc, "Failed to allocate SDO request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
@@ -1212,7 +1209,7 @@
     ret = ec_sdo_request_alloc(req, size);
     if (ret < 0) {
         ec_sdo_request_clear(req);
-        kfree(req);
+        PRT_MemFree(OS_MID_SYS, req);
         return ERR_PTR(ret);
     }
 
@@ -1220,9 +1217,9 @@
     memset(req->data, 0x00, size);
     req->data_size = size;
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->sdo_requests);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
 
     return req;
 }
@@ -1252,20 +1249,20 @@
             __func__, sc, size);
 
     if (!(reg = (ec_reg_request_t *)
-                kmalloc(sizeof(ec_reg_request_t), GFP_KERNEL))) {
+                PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_reg_request_t)))) {
         EC_CONFIG_ERR(sc, "Failed to allocate register request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
 
     ret = ec_reg_request_init(reg, size);
     if (ret) {
-        kfree(reg);
+        PRT_MemFree(OS_MID_SYS, reg);
         return ERR_PTR(ret);
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     list_add_tail(&reg->list, &sc->reg_requests);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
 
     return reg;
 }
@@ -1294,20 +1291,20 @@
     EC_CONFIG_DBG(sc, 1, "%s(sc = 0x%p, size = %zu)\n", __func__, sc, size);
 
     if (!(voe = (ec_voe_handler_t *)
-                kmalloc(sizeof(ec_voe_handler_t), GFP_KERNEL))) {
+                PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_voe_handler_t)))) {
         EC_CONFIG_ERR(sc, "Failed to allocate VoE request memory!\n");
         return ERR_PTR(-ENOMEM);
     }
 
     ret = ec_voe_handler_init(voe, sc, size);
     if (ret < 0) {
-        kfree(voe);
+        PRT_MemFree(OS_MID_SYS, voe);
         return ERR_PTR(ret);
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     list_add_tail(&voe->list, &sc->voe_handlers);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
 
     return voe;
 }
@@ -1370,7 +1367,7 @@
     }
 
     if (!(req = (ec_soe_request_t *)
-          kmalloc(sizeof(ec_soe_request_t), GFP_KERNEL))) {
+          PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_soe_request_t)))) {
         EC_CONFIG_ERR(sc, "Failed to allocate memory for"
                 " IDN configuration!\n");
         return -ENOMEM;
@@ -1384,13 +1381,13 @@
     ret = ec_soe_request_copy_data(req, data, size);
     if (ret < 0) {
         ec_soe_request_clear(req);
-        kfree(req);
+        PRT_MemFree(OS_MID_SYS, req);
         return ret;
     }
 
-    ec_lock_down(&sc->master->master_sem);
+    ec_lock(&sc->master->master_sem);
     list_add_tail(&req->list, &sc->soe_configs);
-    ec_lock_up(&sc->master->master_sem);
+    ec_unlock(&sc->master->master_sem);
     return 0;
 }
 
@@ -1412,54 +1409,22 @@
     else { // new flag
         int ret;
 
-        if (!(flag = (ec_flag_t *) kmalloc(sizeof(ec_flag_t), GFP_KERNEL))) {
+        if (!(flag = (ec_flag_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, sizeof(ec_flag_t)))) {
             EC_CONFIG_ERR(sc, "Failed to allocate memory for flag!\n");
             return -ENOMEM;
         }
 
         ret = ec_flag_init(flag, key, value);
         if (ret) {
-            kfree(flag);
+            PRT_MemFree(OS_MID_SYS, flag);
             return ret;
         }
 
-        ec_lock_down(&sc->master->master_sem);
+        ec_lock(&sc->master->master_sem);
         list_add_tail(&flag->list, &sc->flags);
-        ec_lock_up(&sc->master->master_sem);
+        ec_unlock(&sc->master->master_sem);
     }
     return 0;
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecrt_slave_config_sync_manager);
-EXPORT_SYMBOL(ecrt_slave_config_watchdog);
-EXPORT_SYMBOL(ecrt_slave_config_pdo_assign_add);
-EXPORT_SYMBOL(ecrt_slave_config_pdo_assign_clear);
-EXPORT_SYMBOL(ecrt_slave_config_pdo_mapping_add);
-EXPORT_SYMBOL(ecrt_slave_config_pdo_mapping_clear);
-EXPORT_SYMBOL(ecrt_slave_config_pdos);
-EXPORT_SYMBOL(ecrt_slave_config_reg_pdo_entry);
-EXPORT_SYMBOL(ecrt_slave_config_reg_pdo_entry_pos);
-EXPORT_SYMBOL(ecrt_slave_config_dc);
-EXPORT_SYMBOL(ecrt_slave_config_sdo);
-EXPORT_SYMBOL(ecrt_slave_config_sdo8);
-EXPORT_SYMBOL(ecrt_slave_config_sdo16);
-EXPORT_SYMBOL(ecrt_slave_config_sdo32);
-EXPORT_SYMBOL(ecrt_slave_config_complete_sdo);
-EXPORT_SYMBOL(ecrt_slave_config_emerg_size);
-EXPORT_SYMBOL(ecrt_slave_config_emerg_pop);
-EXPORT_SYMBOL(ecrt_slave_config_emerg_clear);
-EXPORT_SYMBOL(ecrt_slave_config_emerg_overruns);
-EXPORT_SYMBOL(ecrt_slave_config_create_sdo_request);
-EXPORT_SYMBOL(ecrt_slave_config_create_voe_handler);
-EXPORT_SYMBOL(ecrt_slave_config_create_reg_request);
-EXPORT_SYMBOL(ecrt_slave_config_state);
-EXPORT_SYMBOL(ecrt_slave_config_idn);
-EXPORT_SYMBOL(ecrt_slave_config_flag);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/slave_config.h ethercat-master-m/master/slave_config.h
--- ethercat-master/master/slave_config.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/slave_config.h	2023-08-08 19:51:00.965140000 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_SLAVE_CONFIG_H__
 #define __EC_SLAVE_CONFIG_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "slave.h"
 #include "sync_config.h"
@@ -60,7 +58,7 @@
  * \param args arguments (optional)
  */
 #define EC_CONFIG_INFO(sc, fmt, args...) \
-    printk(KERN_INFO "EtherCAT %u %u:%u: " fmt, sc->master->index, \
+    printf("EtherCAT %u %u:%u: " fmt, sc->master->index, \
             sc->alias, sc->position, ##args)
 
 /** Convenience macro for printing configuration-specific errors to syslog.
@@ -74,7 +72,7 @@
  * \param args arguments (optional)
  */
 #define EC_CONFIG_ERR(sc, fmt, args...) \
-    printk(KERN_ERR "EtherCAT ERROR %u %u:%u: " fmt, sc->master->index, \
+    printf("EtherCAT ERROR %u %u:%u: " fmt, sc->master->index, \
             sc->alias, sc->position, ##args)
 
 /** Convenience macro for printing configuration-specific warnings to syslog.
@@ -88,7 +86,7 @@
  * \param args arguments (optional)
  */
 #define EC_CONFIG_WARN(sc, fmt, args...) \
-    printk(KERN_WARNING "EtherCAT WARNING %u %u:%u: " fmt, \
+    printf("EtherCAT WARNING %u %u:%u: " fmt, \
             sc->master->index, sc->alias, sc->position, ##args)
 
 /** Convenience macro for printing configuration-specific debug messages to
@@ -107,7 +105,7 @@
 #define EC_CONFIG_DBG(sc, level, fmt, args...) \
     do { \
         if (sc->master->debug_level >= level) { \
-            printk(KERN_DEBUG "EtherCAT DEBUG %u %u:%u: " fmt, \
+            printf("EtherCAT DEBUG %u %u:%u: " fmt, \
                     sc->master->index, sc->alias, sc->position, ##args); \
         } \
     } while (0)
diff -urN ethercat-master/master/soe_request.c ethercat-master-m/master/soe_request.c
--- ethercat-master/master/soe_request.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/soe_request.c	2023-08-08 19:51:01.094387700 +0800
@@ -33,10 +33,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/slab.h>
-
 #include "soe_request.h"
 
 /*****************************************************************************/
@@ -131,7 +127,7 @@
         )
 {
     if (req->data) {
-        kfree(req->data);
+        PRT_MemFree(OS_MID_SYS, req->data);
         req->data = NULL;
     }
 
@@ -157,7 +153,7 @@
 
     ec_soe_request_clear_data(req);
 
-    if (!(req->data = (uint8_t *) kmalloc(size, GFP_KERNEL))) {
+    if (!(req->data = (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, size))) {
         EC_ERR("Failed to allocate %zu bytes of SoE memory.\n", size);
         return -ENOMEM;
     }
@@ -208,14 +204,14 @@
 {
     if (req->data_size + size > req->mem_size) {
         size_t new_size = req->mem_size ? req->mem_size * 2 : size;
-        uint8_t *new_data = (uint8_t *) kmalloc(new_size, GFP_KERNEL);
+        uint8_t *new_data = (uint8_t *) PRT_MemAlloc(OS_MID_SYS, OS_MEM_DEFAULT_PT0, new_size);
         if (!new_data) {
             EC_ERR("Failed to allocate %zu bytes of SoE memory.\n",
                     new_size);
             return -ENOMEM;
         }
         memcpy(new_data, req->data, req->data_size);
-        kfree(req->data);
+        PRT_MemFree(OS_MID_SYS, req->data);
         req->data = new_data;
         req->mem_size = new_size;
     }
diff -urN ethercat-master/master/soe_request.h ethercat-master-m/master/soe_request.h
--- ethercat-master/master/soe_request.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/soe_request.h	2023-08-08 19:51:00.921120200 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_SOE_REQUEST_H__
 #define __EC_SOE_REQUEST_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 
 /*****************************************************************************/
diff -urN ethercat-master/master/voe_handler.c ethercat-master-m/master/voe_handler.c
--- ethercat-master/master/voe_handler.c	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/voe_handler.c	2023-08-08 19:51:01.639293500 +0800
@@ -33,8 +33,6 @@
 
 /*****************************************************************************/
 
-#include <linux/module.h>
-
 #include "master.h"
 #include "slave_config.h"
 #include "mailbox.h"
@@ -237,7 +235,7 @@
     /* data already in datagram */
 
     voe->retries = EC_FSM_RETRIES;
-    voe->jiffies_start = jiffies;
+    voe->jiffies_start = get_jiffies();
     voe->state = ec_voe_handler_state_write_response;
 }
 
@@ -264,7 +262,7 @@
     if (datagram->working_counter != 1) {
         if (!datagram->working_counter) {
             unsigned long diff_ms =
-                (jiffies - voe->jiffies_start) * 1000 / HZ;
+                (get_jiffies() - voe->jiffies_start) * 1000 / HZ;
             if (diff_ms < EC_VOE_RESPONSE_TIMEOUT) {
                 EC_SLAVE_DBG(slave, 1, "Slave did not respond to"
                         " VoE write request. Retrying after %lu ms...\n",
@@ -304,7 +302,7 @@
         return;
     }
 
-    voe->jiffies_start = jiffies;
+    voe->jiffies_start = get_jiffies();
 
     // mailbox read check is skipped if a read request is already ongoing
     if (ec_read_mbox_locked(slave)) {
@@ -313,7 +311,7 @@
         datagram->state = EC_DATAGRAM_INVALID;
     } else {
         ec_slave_mbox_prepare_check(slave, datagram); // can not fail.
-        voe->jiffies_start = jiffies;
+        voe->jiffies_start = get_jiffies();
         voe->retries = EC_FSM_RETRIES;
         voe->state = ec_voe_handler_state_read_check;
     }
@@ -505,7 +503,7 @@
 
     ec_slave_mbox_prepare_fetch(slave, datagram); // can not fail.
 
-    voe->jiffies_start = jiffies;
+    voe->jiffies_start = get_jiffies();
     voe->retries = EC_FSM_RETRIES;
     voe->state = ec_voe_handler_state_read_nosync_response;
 }
@@ -603,17 +601,3 @@
 }
 
 /*****************************************************************************/
-
-/** \cond */
-
-EXPORT_SYMBOL(ecrt_voe_handler_send_header);
-EXPORT_SYMBOL(ecrt_voe_handler_received_header);
-EXPORT_SYMBOL(ecrt_voe_handler_data);
-EXPORT_SYMBOL(ecrt_voe_handler_data_size);
-EXPORT_SYMBOL(ecrt_voe_handler_read);
-EXPORT_SYMBOL(ecrt_voe_handler_write);
-EXPORT_SYMBOL(ecrt_voe_handler_execute);
-
-/** \endcond */
-
-/*****************************************************************************/
diff -urN ethercat-master/master/voe_handler.h ethercat-master-m/master/voe_handler.h
--- ethercat-master/master/voe_handler.h	2023-06-26 17:45:40.000000000 +0800
+++ ethercat-master-m/master/voe_handler.h	2023-08-08 19:51:01.222547200 +0800
@@ -37,8 +37,6 @@
 #ifndef __EC_VOE_HANDLER_H__
 #define __EC_VOE_HANDLER_H__
 
-#include <linux/list.h>
-
 #include "globals.h"
 #include "datagram.h"
 
